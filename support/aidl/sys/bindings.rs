/* automatically generated by rust-bindgen 0.59.2 */

extern "C" {
    pub fn android_get_application_target_sdk_version() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn android_get_device_api_level() -> ::std::os::raw::c_int;
}
pub type size_t = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __uid_t = __kernel_uid32_t;
pub type uid_t = __uid_t;
pub type __pid_t = __kernel_pid_t;
pub type pid_t = __pid_t;
extern "C" {
    pub fn __errno() -> *mut ::std::os::raw::c_int;
}
#[doc = " One of the STATUS_* values."]
#[doc = ""]
#[doc = " All unrecognized values are coerced into STATUS_UNKNOWN_ERROR."]
pub type binder_status_t = i32;
#[doc = " One of the EXCEPTION_* types."]
#[doc = ""]
#[doc = " All unrecognized values are coerced into EXCEPTION_TRANSACTION_FAILED."]
#[doc = ""]
#[doc = " These exceptions values are used by the SDK for parcelables. Also see Parcel.java."]
pub type binder_exception_t = i32;
#[doc = " This is a helper class that encapsulates a standard way to keep track of and chain binder errors"]
#[doc = " along with service specific errors."]
#[doc = ""]
#[doc = " It is not required to be used in order to parcel/receive transactions, but it is required in"]
#[doc = " order to be compatible with standard AIDL transactions since it is written as the header to the"]
#[doc = " out parcel for transactions which get executed (don't fail during unparceling of input arguments"]
#[doc = " or sooner)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AStatus {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " New status which is considered a success."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\return a newly constructed status object that the caller owns."]
    pub fn AStatus_newOk() -> *mut AStatus;
}
extern "C" {
    #[doc = " New status with exception code."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param exception the code that this status should represent. If this is EX_NONE, then this"]
    #[doc = " constructs an non-error status object."]
    #[doc = ""]
    #[doc = " \\return a newly constructed status object that the caller owns."]
    pub fn AStatus_fromExceptionCode(exception: binder_exception_t) -> *mut AStatus;
}
extern "C" {
    #[doc = " New status with exception code and message."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param exception the code that this status should represent. If this is EX_NONE, then this"]
    #[doc = " constructs an non-error status object."]
    #[doc = " \\param message the error message to associate with this status object."]
    #[doc = ""]
    #[doc = " \\return a newly constructed status object that the caller owns."]
    pub fn AStatus_fromExceptionCodeWithMessage(
        exception: binder_exception_t,
        message: *const ::std::os::raw::c_char,
    ) -> *mut AStatus;
}
extern "C" {
    #[doc = " New status with a service speciic error."]
    #[doc = ""]
    #[doc = " This is considered to be EX_TRANSACTION_FAILED with extra information."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param serviceSpecific an implementation defined error code."]
    #[doc = ""]
    #[doc = " \\return a newly constructed status object that the caller owns."]
    pub fn AStatus_fromServiceSpecificError(serviceSpecific: i32) -> *mut AStatus;
}
extern "C" {
    #[doc = " New status with a service specific error and message."]
    #[doc = ""]
    #[doc = " This is considered to be EX_TRANSACTION_FAILED with extra information."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param serviceSpecific an implementation defined error code."]
    #[doc = " \\param message the error message to associate with this status object."]
    #[doc = ""]
    #[doc = " \\return a newly constructed status object that the caller owns."]
    pub fn AStatus_fromServiceSpecificErrorWithMessage(
        serviceSpecific: i32,
        message: *const ::std::os::raw::c_char,
    ) -> *mut AStatus;
}
extern "C" {
    #[doc = " New status with binder_status_t. This is typically for low level failures when a binder_status_t"]
    #[doc = " is returned by an API on AIBinder or AParcel, and that is to be returned from a method returning"]
    #[doc = " an AStatus instance. This is the least preferable way to return errors."]
    #[doc = " Prefer exceptions (particularly service-specific errors) when possible."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param status a low-level error to associate with this status object."]
    #[doc = ""]
    #[doc = " \\return a newly constructed status object that the caller owns."]
    pub fn AStatus_fromStatus(status: binder_status_t) -> *mut AStatus;
}
extern "C" {
    #[doc = " Whether this object represents a successful transaction. If this function returns true, then"]
    #[doc = " AStatus_getExceptionCode will return EX_NONE."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param status the status being queried."]
    #[doc = ""]
    #[doc = " \\return whether the status represents a successful transaction. For more details, see below."]
    pub fn AStatus_isOk(status: *const AStatus) -> bool;
}
extern "C" {
    #[doc = " The exception that this status object represents."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param status the status being queried."]
    #[doc = ""]
    #[doc = " \\return the exception code that this object represents."]
    pub fn AStatus_getExceptionCode(status: *const AStatus) -> binder_exception_t;
}
extern "C" {
    #[doc = " The service specific error if this object represents one. This function will only ever return a"]
    #[doc = " non-zero result if AStatus_getExceptionCode returns EX_SERVICE_SPECIFIC. If this function returns"]
    #[doc = " 0, the status object may still represent a different exception or status. To find out if this"]
    #[doc = " transaction as a whole is okay, use AStatus_isOk instead."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param status the status being queried."]
    #[doc = ""]
    #[doc = " \\return the service-specific error code if the exception code is EX_SERVICE_SPECIFIC or 0."]
    pub fn AStatus_getServiceSpecificError(status: *const AStatus) -> i32;
}
extern "C" {
    #[doc = " The status if this object represents one. This function will only ever return a non-zero result"]
    #[doc = " if AStatus_getExceptionCode returns EX_TRANSACTION_FAILED. If this function return 0, the status"]
    #[doc = " object may represent a different exception or a service specific error. To find out if this"]
    #[doc = " transaction as a whole is okay, use AStatus_isOk instead."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param status the status being queried."]
    #[doc = ""]
    #[doc = " \\return the status code if the exception code is EX_TRANSACTION_FAILED or 0."]
    pub fn AStatus_getStatus(status: *const AStatus) -> binder_status_t;
}
extern "C" {
    #[doc = " If there is a message associated with this status, this will return that message. If there is no"]
    #[doc = " message, this will return an empty string."]
    #[doc = ""]
    #[doc = " The returned string has the lifetime of the status object passed into this function."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param status the status being queried."]
    #[doc = ""]
    #[doc = " \\return the message associated with this error."]
    pub fn AStatus_getMessage(status: *const AStatus) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get human-readable description for debugging."]
    #[doc = ""]
    #[doc = " Available since API level 30."]
    #[doc = ""]
    #[doc = " \\param status the status being queried."]
    #[doc = ""]
    #[doc = " \\return a description, must be deleted with AStatus_deleteDescription."]
    pub fn AStatus_getDescription(status: *const AStatus) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Delete description."]
    #[doc = ""]
    #[doc = " \\param description value from AStatus_getDescription"]
    pub fn AStatus_deleteDescription(description: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Deletes memory associated with the status instance."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param status the status to delete, returned from AStatus_newOk or one of the AStatus_from* APIs."]
    pub fn AStatus_delete(status: *mut AStatus);
}
#[doc = " Represents a local or remote object which can be used for IPC or which can itself be sent."]
#[doc = ""]
#[doc = " This object has a refcount associated with it and will be deleted when its refcount reaches zero."]
#[doc = " How methods interactive with this refcount is described below. When using this API, it is"]
#[doc = " intended for a client of a service to hold a strong reference to that service. This also means"]
#[doc = " that user data typically should hold a strong reference to a local AIBinder object. A remote"]
#[doc = " AIBinder object automatically holds a strong reference to the AIBinder object in the server's"]
#[doc = " process. A typically memory layout looks like this:"]
#[doc = ""]
#[doc = " Key:"]
#[doc = "   --->         Ownership/a strong reference"]
#[doc = "   ...>         A weak reference"]
#[doc = ""]
#[doc = "                         (process boundary)"]
#[doc = "                                 |"]
#[doc = " MyInterface ---> AIBinder_Weak  |  ProxyForMyInterface"]
#[doc = "      ^                .         |          |"]
#[doc = "      |                .         |          |"]
#[doc = "      |                v         |          v"]
#[doc = "   UserData  <---   AIBinder   <-|-      AIBinder"]
#[doc = "                                 |"]
#[doc = ""]
#[doc = " In this way, you'll notice that a proxy for the interface holds a strong reference to the"]
#[doc = " implementation and that in the server process, the AIBinder object which was sent can be resent"]
#[doc = " so that the same AIBinder object always represents the same object. This allows, for instance, an"]
#[doc = " implementation (usually a callback) to transfer all ownership to a remote process and"]
#[doc = " automatically be deleted when the remote process is done with it or dies. Other memory models are"]
#[doc = " possible, but this is the standard one."]
#[doc = ""]
#[doc = " If the process containing an AIBinder dies, it is possible to be holding a strong reference to"]
#[doc = " an object which does not exist. In this case, transactions to this binder will return"]
#[doc = " STATUS_DEAD_OBJECT. See also AIBinder_linkToDeath, AIBinder_unlinkToDeath, and AIBinder_isAlive."]
#[doc = ""]
#[doc = " Once an AIBinder is created, anywhere it is passed (remotely or locally), there is a 1-1"]
#[doc = " correspondence between the address of an AIBinder and the object it represents. This means that"]
#[doc = " when two AIBinder pointers point to the same address, they represent the same object (whether"]
#[doc = " that object is local or remote). This correspondance can be broken accidentally if AIBinder_new"]
#[doc = " is erronesouly called to create the same object multiple times."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIBinder {
    _unused: [u8; 0],
}
#[doc = " This object represents a package of data that can be sent between processes. When transacting, an"]
#[doc = " instance of it is automatically created to be used for the transaction. When two processes use"]
#[doc = " binder to communicate, they must agree on a format of this parcel to be used in order to transfer"]
#[doc = " data. This is usually done in an IDL (see AIDL, specificially)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AParcel {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Cleans up a parcel."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel A parcel returned by AIBinder_prepareTransaction or AIBinder_transact when a"]
    #[doc = " transaction is being aborted."]
    pub fn AParcel_delete(parcel: *mut AParcel);
}
extern "C" {
    #[doc = " Sets the position within the parcel."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel The parcel of which to set the position."]
    #[doc = " \\param position Position of the parcel to set. This must be a value returned by"]
    #[doc = " AParcel_getDataPosition. Positions are constant for a given parcel between processes."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on success. If position is negative, then STATUS_BAD_VALUE will be returned."]
    pub fn AParcel_setDataPosition(parcel: *const AParcel, position: i32) -> binder_status_t;
}
extern "C" {
    #[doc = " Gets the current position within the parcel."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel The parcel of which to get the position."]
    #[doc = ""]
    #[doc = " \\return The size of the parcel. This will always be greater than 0. The values returned by this"]
    #[doc = " function before and after calling various reads and writes are not defined. Only the delta"]
    #[doc = " between two positions between a specific sequence of calls is defined. For instance, if position"]
    #[doc = " is X, writeBool is called, and then position is Y, readBool can be called from position X will"]
    #[doc = " return the same value, and then position will be Y."]
    pub fn AParcel_getDataPosition(parcel: *const AParcel) -> i32;
}
#[doc = " This is called to allocate a buffer for a C-style string (null-terminated). The returned buffer"]
#[doc = " should be at least length bytes. This includes space for a null terminator. For a string, length"]
#[doc = " will always be strictly less than or equal to the maximum size that can be held in a size_t and"]
#[doc = " will always be greater than 0. However, if a 'null' string is being read, length will be -1."]
#[doc = ""]
#[doc = " See also AParcel_readString."]
#[doc = ""]
#[doc = " If allocation fails, null should be returned."]
#[doc = ""]
#[doc = " \\param stringData some external representation of a string"]
#[doc = " \\param length the length of the buffer needed to fill (including the null-terminator)"]
#[doc = " \\param buffer a buffer of size 'length' or null if allocation failed."]
#[doc = ""]
#[doc = " \\return true if the allocation succeeded, false otherwise. If length is -1, a true return here"]
#[doc = " means that a 'null' value (or equivalent) was successfully stored."]
pub type AParcel_stringAllocator = ::std::option::Option<
    unsafe extern "C" fn(
        stringData: *mut ::std::os::raw::c_void,
        length: i32,
        buffer: *mut *mut ::std::os::raw::c_char,
    ) -> bool,
>;
#[doc = " This is called to allocate an array of size 'length'. If length is -1, then a 'null' array (or"]
#[doc = " equivalent) should be created."]
#[doc = ""]
#[doc = " See also AParcel_readStringArray"]
#[doc = ""]
#[doc = " \\param arrayData some external representation of an array"]
#[doc = " \\param length the length to allocate this array to"]
#[doc = ""]
#[doc = " \\return true if allocation succeeded. If length is -1, a true return here means that a 'null'"]
#[doc = " value (or equivalent) was successfully stored."]
pub type AParcel_stringArrayAllocator = ::std::option::Option<
    unsafe extern "C" fn(arrayData: *mut ::std::os::raw::c_void, length: i32) -> bool,
>;
#[doc = " This is called to allocate a string inside of an array that was allocated by an"]
#[doc = " AParcel_stringArrayAllocator."]
#[doc = ""]
#[doc = " The index returned will always be within the range [0, length of arrayData). The returned buffer"]
#[doc = " should be at least length bytes. This includes space for a null-terminator. For a string, length"]
#[doc = " will always be strictly less than or equal to the maximum size that can be held in a size_t and"]
#[doc = " will always be greater than 0. However, if a 'null' string is being read, length will be -1."]
#[doc = ""]
#[doc = " See also AParcel_readStringArray"]
#[doc = ""]
#[doc = " \\param arrayData some external representation of an array."]
#[doc = " \\param index the index at which a string should be allocated."]
#[doc = " \\param length the length of the string to be allocated at this index. See also"]
#[doc = " AParcel_stringAllocator. This includes the length required for a null-terminator."]
#[doc = " \\param buffer a buffer of size 'length' or null if allocation failed."]
#[doc = ""]
#[doc = " \\return true if the allocation succeeded, false otherwise. If length is -1, a true return here"]
#[doc = " means that a 'null' value (or equivalent) was successfully stored."]
pub type AParcel_stringArrayElementAllocator = ::std::option::Option<
    unsafe extern "C" fn(
        arrayData: *mut ::std::os::raw::c_void,
        index: size_t,
        length: i32,
        buffer: *mut *mut ::std::os::raw::c_char,
    ) -> bool,
>;
#[doc = " This returns the length and buffer of an array at a specific index in an arrayData object."]
#[doc = ""]
#[doc = " See also AParcel_writeStringArray"]
#[doc = ""]
#[doc = " \\param arrayData some external representation of an array."]
#[doc = " \\param index the index at which a string should be allocated."]
#[doc = " \\param outLength an out parameter for the length of the string at the specified index. This"]
#[doc = " should not include the length for a null-terminator if there is one. If the object at this index"]
#[doc = " is 'null', then this should be set to -1."]
#[doc = ""]
#[doc = " \\param a buffer of size outLength or more representing the string at the provided index. This is"]
#[doc = " not required to be null-terminated. If the object at index is null, then this should be null."]
pub type AParcel_stringArrayElementGetter = ::std::option::Option<
    unsafe extern "C" fn(
        arrayData: *const ::std::os::raw::c_void,
        index: size_t,
        outLength: *mut i32,
    ) -> *const ::std::os::raw::c_char,
>;
#[doc = " This is called to allocate an array of size 'length'. If length is -1, then a 'null' array (or"]
#[doc = " equivalent) should be created."]
#[doc = ""]
#[doc = " See also AParcel_readParcelableArray"]
#[doc = ""]
#[doc = " \\param arrayData some external representation of an array"]
#[doc = " \\param length the length to allocate this array to"]
#[doc = ""]
#[doc = " \\return true if allocation succeeded. If length is -1, a true return here means that a 'null'"]
#[doc = " value (or equivalent) was successfully stored."]
pub type AParcel_parcelableArrayAllocator = ::std::option::Option<
    unsafe extern "C" fn(arrayData: *mut ::std::os::raw::c_void, length: i32) -> bool,
>;
#[doc = " This is called to parcel the underlying data from an arrayData object at index."]
#[doc = ""]
#[doc = " See also AParcel_writeParcelableArray"]
#[doc = ""]
#[doc = " \\param parcel parcel to write the parcelable to"]
#[doc = " \\param arrayData some external representation of an array of parcelables (a user-defined type)."]
#[doc = " \\param index the index of the value to be retrieved."]
#[doc = ""]
#[doc = " \\return status (usually returned from other parceling functions). STATUS_OK for success."]
pub type AParcel_writeParcelableElement = ::std::option::Option<
    unsafe extern "C" fn(
        parcel: *mut AParcel,
        arrayData: *const ::std::os::raw::c_void,
        index: size_t,
    ) -> binder_status_t,
>;
#[doc = " This is called to set an underlying value in an arrayData object at index."]
#[doc = ""]
#[doc = " See also AParcel_readParcelableArray"]
#[doc = ""]
#[doc = " \\param parcel parcel to read the parcelable from"]
#[doc = " \\param arrayData some external representation of an array of parcelables (a user-defined type)."]
#[doc = " \\param index the index of the value to be set."]
#[doc = ""]
#[doc = " \\return status (usually returned from other parceling functions). STATUS_OK for success."]
pub type AParcel_readParcelableElement = ::std::option::Option<
    unsafe extern "C" fn(
        parcel: *const AParcel,
        arrayData: *mut ::std::os::raw::c_void,
        index: size_t,
    ) -> binder_status_t,
>;
#[doc = " This is called to get the underlying data from an arrayData object."]
#[doc = ""]
#[doc = " The implementation of this function should allocate a contiguous array of size 'length' and"]
#[doc = " return that underlying buffer to be filled out. If there is an error or length is 0, null may be"]
#[doc = " returned. If length is -1, this should allocate some representation of a null array."]
#[doc = ""]
#[doc = " See also AParcel_readInt32Array"]
#[doc = ""]
#[doc = " \\param arrayData some external representation of an array of int32_t."]
#[doc = " \\param length the length to allocate arrayData to."]
#[doc = " \\param outBuffer a buffer of int32_t of size 'length' (if length is >= 0, if length is 0, this"]
#[doc = " may be nullptr)."]
#[doc = ""]
#[doc = " \\return whether or not the allocation was successful (or whether a null array is represented when"]
#[doc = " length is -1)."]
pub type AParcel_int32ArrayAllocator = ::std::option::Option<
    unsafe extern "C" fn(
        arrayData: *mut ::std::os::raw::c_void,
        length: i32,
        outBuffer: *mut *mut i32,
    ) -> bool,
>;
#[doc = " This is called to get the underlying data from an arrayData object."]
#[doc = ""]
#[doc = " The implementation of this function should allocate a contiguous array of size 'length' and"]
#[doc = " return that underlying buffer to be filled out. If there is an error or length is 0, null may be"]
#[doc = " returned. If length is -1, this should allocate some representation of a null array."]
#[doc = ""]
#[doc = " See also AParcel_readUint32Array"]
#[doc = ""]
#[doc = " \\param arrayData some external representation of an array of uint32_t."]
#[doc = " \\param length the length to allocate arrayData to."]
#[doc = " \\param outBuffer a buffer of uint32_t of size 'length' (if length is >= 0, if length is 0, this"]
#[doc = " may be nullptr)."]
#[doc = ""]
#[doc = " \\return whether or not the allocation was successful (or whether a null array is represented when"]
#[doc = " length is -1)."]
pub type AParcel_uint32ArrayAllocator = ::std::option::Option<
    unsafe extern "C" fn(
        arrayData: *mut ::std::os::raw::c_void,
        length: i32,
        outBuffer: *mut *mut u32,
    ) -> bool,
>;
#[doc = " This is called to get the underlying data from an arrayData object."]
#[doc = ""]
#[doc = " The implementation of this function should allocate a contiguous array of size 'length' and"]
#[doc = " return that underlying buffer to be filled out. If there is an error or length is 0, null may be"]
#[doc = " returned. If length is -1, this should allocate some representation of a null array."]
#[doc = ""]
#[doc = " See also AParcel_readInt64Array"]
#[doc = ""]
#[doc = " \\param arrayData some external representation of an array of int64_t."]
#[doc = " \\param length the length to allocate arrayData to."]
#[doc = " \\param outBuffer a buffer of int64_t of size 'length' (if length is >= 0, if length is 0, this"]
#[doc = " may be nullptr)."]
#[doc = ""]
#[doc = " \\return whether or not the allocation was successful (or whether a null array is represented when"]
#[doc = " length is -1)."]
pub type AParcel_int64ArrayAllocator = ::std::option::Option<
    unsafe extern "C" fn(
        arrayData: *mut ::std::os::raw::c_void,
        length: i32,
        outBuffer: *mut *mut i64,
    ) -> bool,
>;
#[doc = " This is called to get the underlying data from an arrayData object."]
#[doc = ""]
#[doc = " The implementation of this function should allocate a contiguous array of size 'length' and"]
#[doc = " return that underlying buffer to be filled out. If there is an error or length is 0, null may be"]
#[doc = " returned. If length is -1, this should allocate some representation of a null array."]
#[doc = ""]
#[doc = " See also AParcel_readUint64Array"]
#[doc = ""]
#[doc = " \\param arrayData some external representation of an array of uint64_t."]
#[doc = " \\param length the length to allocate arrayData to."]
#[doc = " \\param outBuffer a buffer of uint64_t of size 'length' (if length is >= 0, if length is 0, this"]
#[doc = " may be nullptr)."]
#[doc = ""]
#[doc = " \\return whether or not the allocation was successful (or whether a null array is represented when"]
#[doc = " length is -1)."]
pub type AParcel_uint64ArrayAllocator = ::std::option::Option<
    unsafe extern "C" fn(
        arrayData: *mut ::std::os::raw::c_void,
        length: i32,
        outBuffer: *mut *mut u64,
    ) -> bool,
>;
#[doc = " This is called to get the underlying data from an arrayData object."]
#[doc = ""]
#[doc = " The implementation of this function should allocate a contiguous array of size 'length' and"]
#[doc = " return that underlying buffer to be filled out. If there is an error or length is 0, null may be"]
#[doc = " returned. If length is -1, this should allocate some representation of a null array."]
#[doc = ""]
#[doc = " See also AParcel_readFloatArray"]
#[doc = ""]
#[doc = " \\param arrayData some external representation of an array of float."]
#[doc = " \\param length the length to allocate arrayData to."]
#[doc = " \\param outBuffer a buffer of float of size 'length' (if length is >= 0, if length is 0, this may"]
#[doc = " be nullptr)."]
#[doc = ""]
#[doc = " \\return whether or not the allocation was successful (or whether a null array is represented when"]
#[doc = " length is -1)."]
pub type AParcel_floatArrayAllocator = ::std::option::Option<
    unsafe extern "C" fn(
        arrayData: *mut ::std::os::raw::c_void,
        length: i32,
        outBuffer: *mut *mut f32,
    ) -> bool,
>;
#[doc = " This is called to get the underlying data from an arrayData object."]
#[doc = ""]
#[doc = " The implementation of this function should allocate a contiguous array of size 'length' and"]
#[doc = " return that underlying buffer to be filled out. If there is an error or length is 0, null may be"]
#[doc = " returned. If length is -1, this should allocate some representation of a null array."]
#[doc = ""]
#[doc = " See also AParcel_readDoubleArray"]
#[doc = ""]
#[doc = " \\param arrayData some external representation of an array of double."]
#[doc = " \\param length the length to allocate arrayData to."]
#[doc = " \\param outBuffer a buffer of double of size 'length' (if length is >= 0, if length is 0, this may"]
#[doc = " be nullptr)."]
#[doc = ""]
#[doc = " \\return whether or not the allocation was successful (or whether a null array is represented when"]
#[doc = " length is -1)."]
pub type AParcel_doubleArrayAllocator = ::std::option::Option<
    unsafe extern "C" fn(
        arrayData: *mut ::std::os::raw::c_void,
        length: i32,
        outBuffer: *mut *mut f64,
    ) -> bool,
>;
#[doc = " This allocates an array of size 'length' inside of arrayData and returns whether or not there was"]
#[doc = " a success. If length is -1, then this should allocate some representation of a null array."]
#[doc = ""]
#[doc = " See also AParcel_readBoolArray"]
#[doc = ""]
#[doc = " \\param arrayData some external representation of an array of bool."]
#[doc = " \\param length the length to allocate arrayData to (or -1 if this represents a null array)."]
#[doc = ""]
#[doc = " \\return whether the allocation succeeded."]
pub type AParcel_boolArrayAllocator = ::std::option::Option<
    unsafe extern "C" fn(arrayData: *mut ::std::os::raw::c_void, length: i32) -> bool,
>;
#[doc = " This is called to get the underlying data from an arrayData object at index."]
#[doc = ""]
#[doc = " See also AParcel_writeBoolArray"]
#[doc = ""]
#[doc = " \\param arrayData some external representation of an array of bool."]
#[doc = " \\param index the index of the value to be retrieved."]
#[doc = ""]
#[doc = " \\return the value of the array at index index."]
pub type AParcel_boolArrayGetter = ::std::option::Option<
    unsafe extern "C" fn(arrayData: *const ::std::os::raw::c_void, index: size_t) -> bool,
>;
#[doc = " This is called to set an underlying value in an arrayData object at index."]
#[doc = ""]
#[doc = " See also AParcel_readBoolArray"]
#[doc = ""]
#[doc = " \\param arrayData some external representation of an array of bool."]
#[doc = " \\param index the index of the value to be set."]
#[doc = " \\param value the value to set at index index."]
pub type AParcel_boolArraySetter = ::std::option::Option<
    unsafe extern "C" fn(arrayData: *mut ::std::os::raw::c_void, index: size_t, value: bool),
>;
#[doc = " This is called to get the underlying data from an arrayData object."]
#[doc = ""]
#[doc = " The implementation of this function should allocate a contiguous array of size 'length' and"]
#[doc = " return that underlying buffer to be filled out. If there is an error or length is 0, null may be"]
#[doc = " returned. If length is -1, this should allocate some representation of a null array."]
#[doc = ""]
#[doc = " See also AParcel_readCharArray"]
#[doc = ""]
#[doc = " \\param arrayData some external representation of an array of char16_t."]
#[doc = " \\param length the length to allocate arrayData to."]
#[doc = " \\param outBuffer a buffer of char16_t of size 'length' (if length is >= 0, if length is 0, this"]
#[doc = " may be nullptr)."]
#[doc = ""]
#[doc = " \\return whether or not the allocation was successful (or whether a null array is represented when"]
#[doc = " length is -1)."]
pub type AParcel_charArrayAllocator = ::std::option::Option<
    unsafe extern "C" fn(
        arrayData: *mut ::std::os::raw::c_void,
        length: i32,
        outBuffer: *mut *mut u16,
    ) -> bool,
>;
#[doc = " This is called to get the underlying data from an arrayData object."]
#[doc = ""]
#[doc = " The implementation of this function should allocate a contiguous array of size 'length' and"]
#[doc = " return that underlying buffer to be filled out. If there is an error or length is 0, null may be"]
#[doc = " returned. If length is -1, this should allocate some representation of a null array."]
#[doc = ""]
#[doc = " See also AParcel_readByteArray"]
#[doc = ""]
#[doc = " \\param arrayData some external representation of an array of int8_t."]
#[doc = " \\param length the length to allocate arrayData to."]
#[doc = " \\param outBuffer a buffer of int8_t of size 'length' (if length is >= 0, if length is 0, this may"]
#[doc = " be nullptr)."]
#[doc = ""]
#[doc = " \\return whether or not the allocation was successful (or whether a null array is represented when"]
#[doc = " length is -1)."]
pub type AParcel_byteArrayAllocator = ::std::option::Option<
    unsafe extern "C" fn(
        arrayData: *mut ::std::os::raw::c_void,
        length: i32,
        outBuffer: *mut *mut i8,
    ) -> bool,
>;
extern "C" {
    #[doc = " Writes an AIBinder to the next location in a non-null parcel. Can be null. This does not take any"]
    #[doc = " refcounts of ownership of the binder from the client."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel the parcel to write to."]
    #[doc = " \\param binder the value to write to the parcel."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on successful write."]
    pub fn AParcel_writeStrongBinder(
        parcel: *mut AParcel,
        binder: *mut AIBinder,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads an AIBinder from the next location in a non-null parcel. One strong ref-count of ownership"]
    #[doc = " is passed to the caller of this function."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel the parcel to read from."]
    #[doc = " \\param binder the out parameter for what is read from the parcel. This may be null."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on successful write."]
    pub fn AParcel_readStrongBinder(
        parcel: *const AParcel,
        binder: *mut *mut AIBinder,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes a file descriptor to the next location in a non-null parcel. This does not take ownership"]
    #[doc = " of fd."]
    #[doc = ""]
    #[doc = " This corresponds to the SDK's android.os.ParcelFileDescriptor."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel the parcel to write to."]
    #[doc = " \\param fd the value to write to the parcel (-1 to represent a null ParcelFileDescriptor)."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on successful write."]
    pub fn AParcel_writeParcelFileDescriptor(
        parcel: *mut AParcel,
        fd: ::std::os::raw::c_int,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads an int from the next location in a non-null parcel."]
    #[doc = ""]
    #[doc = " The returned fd must be closed."]
    #[doc = ""]
    #[doc = " This corresponds to the SDK's android.os.ParcelFileDescriptor."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel the parcel to read from."]
    #[doc = " \\param fd the out parameter for what is read from the parcel (or -1 to represent a null"]
    #[doc = " ParcelFileDescriptor)"]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on successful write."]
    pub fn AParcel_readParcelFileDescriptor(
        parcel: *const AParcel,
        fd: *mut ::std::os::raw::c_int,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes an AStatus object to the next location in a non-null parcel."]
    #[doc = ""]
    #[doc = " If the status is considered to be a low-level status and has no additional information other"]
    #[doc = " than a binder_status_t (for instance, if it is created with AStatus_fromStatus), then that"]
    #[doc = " status will be returned from this method and nothing will be written to the parcel. If either"]
    #[doc = " this happens or if writing the status object itself fails, the return value from this function"]
    #[doc = " should be propagated to the client, and AParcel_readStatusHeader shouldn't be called."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel the parcel to write to."]
    #[doc = " \\param status the value to write to the parcel."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on successful write."]
    pub fn AParcel_writeStatusHeader(
        parcel: *mut AParcel,
        status: *const AStatus,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads an AStatus from the next location in a non-null parcel. Ownership is passed to the caller"]
    #[doc = " of this function."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel the parcel to read from."]
    #[doc = " \\param status the out parameter for what is read from the parcel."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on successful write."]
    pub fn AParcel_readStatusHeader(
        parcel: *const AParcel,
        status: *mut *mut AStatus,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes utf-8 string value to the next location in a non-null parcel."]
    #[doc = ""]
    #[doc = " If length is -1, and string is nullptr, this will write a 'null' string to the parcel."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel the parcel to write to."]
    #[doc = " \\param string the null-terminated string to write to the parcel, at least of size 'length'."]
    #[doc = " \\param length the length of the string to be written."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on successful write."]
    pub fn AParcel_writeString(
        parcel: *mut AParcel,
        string: *const ::std::os::raw::c_char,
        length: i32,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads and allocates utf-8 string value from the next location in a non-null parcel."]
    #[doc = ""]
    #[doc = " Data is passed to the string allocator once the string size is known. This size includes the"]
    #[doc = " space for the null-terminator of this string. This allocator returns a buffer which is used as"]
    #[doc = " the output buffer from this read. If there is a 'null' string on the binder buffer, the allocator"]
    #[doc = " will be called with length -1."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel the parcel to read from."]
    #[doc = " \\param stringData some external representation of a string."]
    #[doc = " \\param allocator allocator that will be called once the size of the string is known."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on successful write."]
    pub fn AParcel_readString(
        parcel: *const AParcel,
        stringData: *mut ::std::os::raw::c_void,
        allocator: AParcel_stringAllocator,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes utf-8 string array data to the next location in a non-null parcel."]
    #[doc = ""]
    #[doc = " length is the length of the array. AParcel_stringArrayElementGetter will be called for all"]
    #[doc = " indices in range [0, length) with the arrayData provided here. The string length and buffer"]
    #[doc = " returned from this function will be used to fill out the data from the parcel. If length is -1,"]
    #[doc = " this will write a 'null' string array to the binder buffer."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel the parcel to write to."]
    #[doc = " \\param arrayData some external representation of an array."]
    #[doc = " \\param length the length of the array to be written."]
    #[doc = " \\param getter the callback that will be called for every index of the array to retrieve the"]
    #[doc = " corresponding string buffer."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on successful write."]
    pub fn AParcel_writeStringArray(
        parcel: *mut AParcel,
        arrayData: *const ::std::os::raw::c_void,
        length: i32,
        getter: AParcel_stringArrayElementGetter,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads and allocates utf-8 string array value from the next location in a non-null parcel."]
    #[doc = ""]
    #[doc = " First, AParcel_stringArrayAllocator will be called with the size of the array to be read where"]
    #[doc = " length is the length of the array to be read from the parcel. Then, for each index i in [0,"]
    #[doc = " length), AParcel_stringArrayElementAllocator will be called with the length of the string to be"]
    #[doc = " read from the parcel. The resultant buffer from each of these calls will be filled according to"]
    #[doc = " the contents of the string that is read. If the string array being read is 'null', this will"]
    #[doc = " instead just pass -1 to AParcel_stringArrayAllocator."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel the parcel to read from."]
    #[doc = " \\param arrayData some external representation of an array."]
    #[doc = " \\param allocator the callback that will be called with arrayData once the size of the output"]
    #[doc = " array is known."]
    #[doc = " \\param elementAllocator the callback that will be called on every index of arrayData to allocate"]
    #[doc = " the string at that location."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on successful read."]
    pub fn AParcel_readStringArray(
        parcel: *const AParcel,
        arrayData: *mut ::std::os::raw::c_void,
        allocator: AParcel_stringArrayAllocator,
        elementAllocator: AParcel_stringArrayElementAllocator,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes an array of parcelables (user-defined types) to the next location in a non-null parcel."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel the parcel to write to."]
    #[doc = " \\param arrayData an array of size 'length' (or null if length is -1, may be null if length is 0)."]
    #[doc = " \\param length the length of arrayData or -1 if this represents a null array."]
    #[doc = " \\param elementWriter function to be called for every array index to write the user-defined type"]
    #[doc = " at that location."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on successful write."]
    pub fn AParcel_writeParcelableArray(
        parcel: *mut AParcel,
        arrayData: *const ::std::os::raw::c_void,
        length: i32,
        elementWriter: AParcel_writeParcelableElement,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads an array of parcelables (user-defined types) from the next location in a non-null parcel."]
    #[doc = ""]
    #[doc = " First, allocator will be called with the length of the array. If the allocation succeeds and the"]
    #[doc = " length is greater than zero, elementReader will be called for every index to read the"]
    #[doc = " corresponding parcelable."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel the parcel to read from."]
    #[doc = " \\param arrayData some external representation of an array."]
    #[doc = " \\param allocator the callback that will be called to allocate the array."]
    #[doc = " \\param elementReader the callback that will be called to fill out individual elements."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on successful read."]
    pub fn AParcel_readParcelableArray(
        parcel: *const AParcel,
        arrayData: *mut ::std::os::raw::c_void,
        allocator: AParcel_parcelableArrayAllocator,
        elementReader: AParcel_readParcelableElement,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes int32_t value to the next location in a non-null parcel."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel the parcel to write to."]
    #[doc = " \\param value the value to write to the parcel."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on successful write."]
    pub fn AParcel_writeInt32(parcel: *mut AParcel, value: i32) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes uint32_t value to the next location in a non-null parcel."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel the parcel to write to."]
    #[doc = " \\param value the value to write to the parcel."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on successful write."]
    pub fn AParcel_writeUint32(parcel: *mut AParcel, value: u32) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes int64_t value to the next location in a non-null parcel."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel the parcel to write to."]
    #[doc = " \\param value the value to write to the parcel."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on successful write."]
    pub fn AParcel_writeInt64(parcel: *mut AParcel, value: i64) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes uint64_t value to the next location in a non-null parcel."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel the parcel to write to."]
    #[doc = " \\param value the value to write to the parcel."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on successful write."]
    pub fn AParcel_writeUint64(parcel: *mut AParcel, value: u64) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes float value to the next location in a non-null parcel."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel the parcel to write to."]
    #[doc = " \\param value the value to write to the parcel."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on successful write."]
    pub fn AParcel_writeFloat(parcel: *mut AParcel, value: f32) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes double value to the next location in a non-null parcel."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel the parcel to write to."]
    #[doc = " \\param value the value to write to the parcel."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on successful write."]
    pub fn AParcel_writeDouble(parcel: *mut AParcel, value: f64) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes bool value to the next location in a non-null parcel."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel the parcel to write to."]
    #[doc = " \\param value the value to write to the parcel."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on successful write."]
    pub fn AParcel_writeBool(parcel: *mut AParcel, value: bool) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes char16_t value to the next location in a non-null parcel."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel the parcel to write to."]
    #[doc = " \\param value the value to write to the parcel."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on successful write."]
    pub fn AParcel_writeChar(parcel: *mut AParcel, value: u16) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes int8_t value to the next location in a non-null parcel."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel the parcel to write to."]
    #[doc = " \\param value the value to write to the parcel."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on successful write."]
    pub fn AParcel_writeByte(parcel: *mut AParcel, value: i8) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads into int32_t value from the next location in a non-null parcel."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel the parcel to read from."]
    #[doc = " \\param value the value to read from the parcel."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on successful read."]
    pub fn AParcel_readInt32(parcel: *const AParcel, value: *mut i32) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads into uint32_t value from the next location in a non-null parcel."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel the parcel to read from."]
    #[doc = " \\param value the value to read from the parcel."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on successful read."]
    pub fn AParcel_readUint32(parcel: *const AParcel, value: *mut u32) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads into int64_t value from the next location in a non-null parcel."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel the parcel to read from."]
    #[doc = " \\param value the value to read from the parcel."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on successful read."]
    pub fn AParcel_readInt64(parcel: *const AParcel, value: *mut i64) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads into uint64_t value from the next location in a non-null parcel."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel the parcel to read from."]
    #[doc = " \\param value the value to read from the parcel."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on successful read."]
    pub fn AParcel_readUint64(parcel: *const AParcel, value: *mut u64) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads into float value from the next location in a non-null parcel."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel the parcel to read from."]
    #[doc = " \\param value the value to read from the parcel."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on successful read."]
    pub fn AParcel_readFloat(parcel: *const AParcel, value: *mut f32) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads into double value from the next location in a non-null parcel."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel the parcel to read from."]
    #[doc = " \\param value the value to read from the parcel."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on successful read."]
    pub fn AParcel_readDouble(parcel: *const AParcel, value: *mut f64) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads into bool value from the next location in a non-null parcel."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel the parcel to read from."]
    #[doc = " \\param value the value to read from the parcel."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on successful read."]
    pub fn AParcel_readBool(parcel: *const AParcel, value: *mut bool) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads into char16_t value from the next location in a non-null parcel."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel the parcel to read from."]
    #[doc = " \\param value the value to read from the parcel."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on successful read."]
    pub fn AParcel_readChar(parcel: *const AParcel, value: *mut u16) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads into int8_t value from the next location in a non-null parcel."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel the parcel to read from."]
    #[doc = " \\param value the value to read from the parcel."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on successful read."]
    pub fn AParcel_readByte(parcel: *const AParcel, value: *mut i8) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes an array of int32_t to the next location in a non-null parcel."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel the parcel to write to."]
    #[doc = " \\param arrayData an array of size 'length' (or null if length is -1, may be null if length is 0)."]
    #[doc = " \\param length the length of arrayData or -1 if this represents a null array."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on successful write."]
    pub fn AParcel_writeInt32Array(
        parcel: *mut AParcel,
        arrayData: *const i32,
        length: i32,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes an array of uint32_t to the next location in a non-null parcel."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel the parcel to write to."]
    #[doc = " \\param arrayData an array of size 'length' (or null if length is -1, may be null if length is 0)."]
    #[doc = " \\param length the length of arrayData or -1 if this represents a null array."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on successful write."]
    pub fn AParcel_writeUint32Array(
        parcel: *mut AParcel,
        arrayData: *const u32,
        length: i32,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes an array of int64_t to the next location in a non-null parcel."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel the parcel to write to."]
    #[doc = " \\param arrayData an array of size 'length' (or null if length is -1, may be null if length is 0)."]
    #[doc = " \\param length the length of arrayData or -1 if this represents a null array."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on successful write."]
    pub fn AParcel_writeInt64Array(
        parcel: *mut AParcel,
        arrayData: *const i64,
        length: i32,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes an array of uint64_t to the next location in a non-null parcel."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel the parcel to write to."]
    #[doc = " \\param arrayData an array of size 'length' (or null if length is -1, may be null if length is 0)."]
    #[doc = " \\param length the length of arrayData or -1 if this represents a null array."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on successful write."]
    pub fn AParcel_writeUint64Array(
        parcel: *mut AParcel,
        arrayData: *const u64,
        length: i32,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes an array of float to the next location in a non-null parcel."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel the parcel to write to."]
    #[doc = " \\param arrayData an array of size 'length' (or null if length is -1, may be null if length is 0)."]
    #[doc = " \\param length the length of arrayData or -1 if this represents a null array."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on successful write."]
    pub fn AParcel_writeFloatArray(
        parcel: *mut AParcel,
        arrayData: *const f32,
        length: i32,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes an array of double to the next location in a non-null parcel."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel the parcel to write to."]
    #[doc = " \\param arrayData an array of size 'length' (or null if length is -1, may be null if length is 0)."]
    #[doc = " \\param length the length of arrayData or -1 if this represents a null array."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on successful write."]
    pub fn AParcel_writeDoubleArray(
        parcel: *mut AParcel,
        arrayData: *const f64,
        length: i32,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes an array of bool to the next location in a non-null parcel."]
    #[doc = ""]
    #[doc = " getter(arrayData, i) will be called for each i in [0, length) in order to get the underlying"]
    #[doc = " values to write to the parcel."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel the parcel to write to."]
    #[doc = " \\param arrayData some external representation of an array."]
    #[doc = " \\param length the length of arrayData (or -1 if this represents a null array)."]
    #[doc = " \\param getter the callback to retrieve data at specific locations in the array."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on successful write."]
    pub fn AParcel_writeBoolArray(
        parcel: *mut AParcel,
        arrayData: *const ::std::os::raw::c_void,
        length: i32,
        getter: AParcel_boolArrayGetter,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes an array of char16_t to the next location in a non-null parcel."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel the parcel to write to."]
    #[doc = " \\param arrayData an array of size 'length' (or null if length is -1, may be null if length is 0)."]
    #[doc = " \\param length the length of arrayData or -1 if this represents a null array."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on successful write."]
    pub fn AParcel_writeCharArray(
        parcel: *mut AParcel,
        arrayData: *const u16,
        length: i32,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes an array of int8_t to the next location in a non-null parcel."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel the parcel to write to."]
    #[doc = " \\param arrayData an array of size 'length' (or null if length is -1, may be null if length is 0)."]
    #[doc = " \\param length the length of arrayData or -1 if this represents a null array."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on successful write."]
    pub fn AParcel_writeByteArray(
        parcel: *mut AParcel,
        arrayData: *const i8,
        length: i32,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads an array of int32_t from the next location in a non-null parcel."]
    #[doc = ""]
    #[doc = " First, allocator will be called with the length of the array. If the allocation succeeds and the"]
    #[doc = " length is greater than zero, the buffer returned by the allocator will be filled with the"]
    #[doc = " corresponding data"]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel the parcel to read from."]
    #[doc = " \\param arrayData some external representation of an array."]
    #[doc = " \\param allocator the callback that will be called to allocate the array."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on successful read."]
    pub fn AParcel_readInt32Array(
        parcel: *const AParcel,
        arrayData: *mut ::std::os::raw::c_void,
        allocator: AParcel_int32ArrayAllocator,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads an array of uint32_t from the next location in a non-null parcel."]
    #[doc = ""]
    #[doc = " First, allocator will be called with the length of the array. If the allocation succeeds and the"]
    #[doc = " length is greater than zero, the buffer returned by the allocator will be filled with the"]
    #[doc = " corresponding data"]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel the parcel to read from."]
    #[doc = " \\param arrayData some external representation of an array."]
    #[doc = " \\param allocator the callback that will be called to allocate the array."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on successful read."]
    pub fn AParcel_readUint32Array(
        parcel: *const AParcel,
        arrayData: *mut ::std::os::raw::c_void,
        allocator: AParcel_uint32ArrayAllocator,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads an array of int64_t from the next location in a non-null parcel."]
    #[doc = ""]
    #[doc = " First, allocator will be called with the length of the array. If the allocation succeeds and the"]
    #[doc = " length is greater than zero, the buffer returned by the allocator will be filled with the"]
    #[doc = " corresponding data"]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel the parcel to read from."]
    #[doc = " \\param arrayData some external representation of an array."]
    #[doc = " \\param allocator the callback that will be called to allocate the array."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on successful read."]
    pub fn AParcel_readInt64Array(
        parcel: *const AParcel,
        arrayData: *mut ::std::os::raw::c_void,
        allocator: AParcel_int64ArrayAllocator,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads an array of uint64_t from the next location in a non-null parcel."]
    #[doc = ""]
    #[doc = " First, allocator will be called with the length of the array. If the allocation succeeds and the"]
    #[doc = " length is greater than zero, the buffer returned by the allocator will be filled with the"]
    #[doc = " corresponding data"]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel the parcel to read from."]
    #[doc = " \\param arrayData some external representation of an array."]
    #[doc = " \\param allocator the callback that will be called to allocate the array."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on successful read."]
    pub fn AParcel_readUint64Array(
        parcel: *const AParcel,
        arrayData: *mut ::std::os::raw::c_void,
        allocator: AParcel_uint64ArrayAllocator,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads an array of float from the next location in a non-null parcel."]
    #[doc = ""]
    #[doc = " First, allocator will be called with the length of the array. If the allocation succeeds and the"]
    #[doc = " length is greater than zero, the buffer returned by the allocator will be filled with the"]
    #[doc = " corresponding data"]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel the parcel to read from."]
    #[doc = " \\param arrayData some external representation of an array."]
    #[doc = " \\param allocator the callback that will be called to allocate the array."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on successful read."]
    pub fn AParcel_readFloatArray(
        parcel: *const AParcel,
        arrayData: *mut ::std::os::raw::c_void,
        allocator: AParcel_floatArrayAllocator,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads an array of double from the next location in a non-null parcel."]
    #[doc = ""]
    #[doc = " First, allocator will be called with the length of the array. If the allocation succeeds and the"]
    #[doc = " length is greater than zero, the buffer returned by the allocator will be filled with the"]
    #[doc = " corresponding data"]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel the parcel to read from."]
    #[doc = " \\param arrayData some external representation of an array."]
    #[doc = " \\param allocator the callback that will be called to allocate the array."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on successful read."]
    pub fn AParcel_readDoubleArray(
        parcel: *const AParcel,
        arrayData: *mut ::std::os::raw::c_void,
        allocator: AParcel_doubleArrayAllocator,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads an array of bool from the next location in a non-null parcel."]
    #[doc = ""]
    #[doc = " First, allocator will be called with the length of the array. Then, for every i in [0, length),"]
    #[doc = " setter(arrayData, i, x) will be called where x is the value at the associated index."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel the parcel to read from."]
    #[doc = " \\param arrayData some external representation of an array."]
    #[doc = " \\param allocator the callback that will be called to allocate the array."]
    #[doc = " \\param setter the callback that will be called to set a value at a specific location in the"]
    #[doc = " array."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on successful read."]
    pub fn AParcel_readBoolArray(
        parcel: *const AParcel,
        arrayData: *mut ::std::os::raw::c_void,
        allocator: AParcel_boolArrayAllocator,
        setter: AParcel_boolArraySetter,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads an array of char16_t from the next location in a non-null parcel."]
    #[doc = ""]
    #[doc = " First, allocator will be called with the length of the array. If the allocation succeeds and the"]
    #[doc = " length is greater than zero, the buffer returned by the allocator will be filled with the"]
    #[doc = " corresponding data"]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel the parcel to read from."]
    #[doc = " \\param arrayData some external representation of an array."]
    #[doc = " \\param allocator the callback that will be called to allocate the array."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on successful read."]
    pub fn AParcel_readCharArray(
        parcel: *const AParcel,
        arrayData: *mut ::std::os::raw::c_void,
        allocator: AParcel_charArrayAllocator,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads an array of int8_t from the next location in a non-null parcel."]
    #[doc = ""]
    #[doc = " First, allocator will be called with the length of the array. If the allocation succeeds and the"]
    #[doc = " length is greater than zero, the buffer returned by the allocator will be filled with the"]
    #[doc = " corresponding data"]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param parcel the parcel to read from."]
    #[doc = " \\param arrayData some external representation of an array."]
    #[doc = " \\param allocator the callback that will be called to allocate the array."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on successful read."]
    pub fn AParcel_readByteArray(
        parcel: *const AParcel,
        arrayData: *mut ::std::os::raw::c_void,
        allocator: AParcel_byteArrayAllocator,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Reset the parcel to the initial status."]
    #[doc = ""]
    #[doc = " Available since API level 31."]
    #[doc = ""]
    #[doc = " \\param parcel The parcel of which to be reset."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on success."]
    pub fn AParcel_reset(parcel: *mut AParcel) -> binder_status_t;
}
extern "C" {
    #[doc = " Gets the size of the parcel."]
    #[doc = ""]
    #[doc = " Available since API level 31."]
    #[doc = ""]
    #[doc = " \\param parcel The parcel of which to get the size."]
    #[doc = ""]
    #[doc = " \\return The size of the parcel."]
    pub fn AParcel_getDataSize(parcel: *const AParcel) -> i32;
}
extern "C" {
    #[doc = " Copy the data of a parcel to other parcel."]
    #[doc = ""]
    #[doc = " Available since API level 31."]
    #[doc = ""]
    #[doc = " \\param from The source"]
    #[doc = " \\param to The detination"]
    #[doc = " \\param start The position where the copied data starts."]
    #[doc = " \\param size The amount of data which will be copied."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on success."]
    pub fn AParcel_appendFrom(
        from: *const AParcel,
        to: *mut AParcel,
        start: i32,
        size: i32,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Creates a parcel."]
    #[doc = ""]
    #[doc = " Available since API level 31."]
    #[doc = ""]
    #[doc = " \\return A parcel which is not related to any IBinder objects."]
    pub fn AParcel_create() -> *mut AParcel;
}
extern "C" {
    #[doc = " Marshals the raw bytes of the Parcel to a buffer."]
    #[doc = ""]
    #[doc = " Available since API level 33."]
    #[doc = ""]
    #[doc = " The parcel must not contain any binders or file descriptors."]
    #[doc = ""]
    #[doc = " The data you retrieve here must not be placed in any kind of persistent storage. (on local disk,"]
    #[doc = " across a network, etc). For that, you should use standard serialization or another kind of"]
    #[doc = " general serialization mechanism. The Parcel marshalled representation is highly optimized for"]
    #[doc = " local IPC, and as such does not attempt to maintain compatibility with data created in different"]
    #[doc = " versions of the platform."]
    #[doc = ""]
    #[doc = " \\param parcel The parcel of which to get the data."]
    #[doc = " \\param buffer The buffer to copy the raw bytes to."]
    #[doc = " \\param start The start position in the buffer to copy from."]
    #[doc = " \\param len The size of the data to copy, buffer size must be larger or equal to this."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on success, STATUS_INVALID_OPERATION if parcel contains binders or file"]
    #[doc = " descriptors. STATUS_BAD_VALUE if the buffer size is less than parcel size."]
    pub fn AParcel_marshal(
        parcel: *const AParcel,
        buffer: *mut u8,
        start: size_t,
        len: size_t,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Set the data in the parcel to the raw bytes from the buffer."]
    #[doc = ""]
    #[doc = " Available since API level 33."]
    #[doc = ""]
    #[doc = " \\param parcel The parcel to set data."]
    #[doc = " \\param buffer The data buffer to set."]
    #[doc = " \\param len The size of the data to set."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on success."]
    pub fn AParcel_unmarshal(
        parcel: *mut AParcel,
        buffer: *const u8,
        len: size_t,
    ) -> binder_status_t;
}
#[doc = " Flags for AIBinder_transact."]
pub type binder_flags_t = u32;
#[doc = " Codes for AIBinder_transact. This defines the range of codes available for"]
#[doc = " usage. Other codes are used or reserved by the Android system."]
pub type transaction_code_t = u32;
#[doc = " Represents a type of AIBinder object which can be sent out."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIBinder_Class {
    _unused: [u8; 0],
}
#[doc = " The AIBinder object associated with this can be retrieved if it is still alive so that it can be"]
#[doc = " re-used. The intention of this is to enable the same AIBinder object to always represent the same"]
#[doc = " object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIBinder_Weak {
    _unused: [u8; 0],
}
#[doc = " Represents a handle on a death notification. See AIBinder_linkToDeath/AIBinder_unlinkToDeath."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIBinder_DeathRecipient {
    _unused: [u8; 0],
}
#[doc = " This is called whenever a new AIBinder object is needed of a specific class."]
#[doc = ""]
#[doc = " \\param args these can be used to construct a new class. These are passed from AIBinder_new."]
#[doc = " \\return this is the userdata representing the class. It can be retrieved using"]
#[doc = " AIBinder_getUserData."]
pub type AIBinder_Class_onCreate = ::std::option::Option<
    unsafe extern "C" fn(args: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
>;
#[doc = " This is called whenever an AIBinder object is no longer referenced and needs destroyed."]
#[doc = ""]
#[doc = " Typically, this just deletes whatever the implementation is."]
#[doc = ""]
#[doc = " \\param userData this is the same object returned by AIBinder_Class_onCreate"]
pub type AIBinder_Class_onDestroy =
    ::std::option::Option<unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void)>;
#[doc = " This is called whenever a transaction needs to be processed by a local implementation."]
#[doc = ""]
#[doc = " This method will be called after the equivalent of"]
#[doc = " android.os.Parcel#enforceInterface is called. That is, the interface"]
#[doc = " descriptor associated with the AIBinder_Class descriptor will already be"]
#[doc = " checked."]
#[doc = ""]
#[doc = " \\param binder the object being transacted on."]
#[doc = " \\param code implementation-specific code representing which transaction should be taken."]
#[doc = " \\param in the implementation-specific input data to this transaction."]
#[doc = " \\param out the implementation-specific output data to this transaction."]
#[doc = ""]
#[doc = " \\return the implementation-specific output code. This may be forwarded from another service, the"]
#[doc = " result of a parcel read or write, or another error as is applicable to the specific"]
#[doc = " implementation. Usually, implementation-specific error codes are written to the output parcel,"]
#[doc = " and the transaction code is reserved for kernel errors or error codes that have been repeated"]
#[doc = " from subsequent transactions."]
pub type AIBinder_Class_onTransact = ::std::option::Option<
    unsafe extern "C" fn(
        binder: *mut AIBinder,
        code: transaction_code_t,
        in_: *const AParcel,
        out: *mut AParcel,
    ) -> binder_status_t,
>;
extern "C" {
    #[doc = " This creates a new instance of a class of binders which can be instantiated. This is called one"]
    #[doc = " time during library initialization and cleaned up when the process exits or execs."]
    #[doc = ""]
    #[doc = " None of these parameters can be null."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param interfaceDescriptor this is a unique identifier for the class. This is used internally for"]
    #[doc = " validity checks on transactions. This should be utf-8."]
    #[doc = " \\param onCreate see AIBinder_Class_onCreate."]
    #[doc = " \\param onDestroy see AIBinder_Class_onDestroy."]
    #[doc = " \\param onTransact see AIBinder_Class_onTransact."]
    #[doc = ""]
    #[doc = " \\return the class object representing these parameters or null on error."]
    pub fn AIBinder_Class_define(
        interfaceDescriptor: *const ::std::os::raw::c_char,
        onCreate: AIBinder_Class_onCreate,
        onDestroy: AIBinder_Class_onDestroy,
        onTransact: AIBinder_Class_onTransact,
    ) -> *mut AIBinder_Class;
}
#[doc = " Dump information about an AIBinder (usually for debugging)."]
#[doc = ""]
#[doc = " When no arguments are provided, a brief overview of the interview should be given."]
#[doc = ""]
#[doc = " \\param binder interface being dumped"]
#[doc = " \\param fd file descriptor to be dumped to, should be flushed, ownership is not passed."]
#[doc = " \\param args array of null-terminated strings for dump (may be null if numArgs is 0)"]
#[doc = " \\param numArgs number of args to be sent"]
#[doc = ""]
#[doc = " \\return binder_status_t result of transaction (if remote, for instance)"]
pub type AIBinder_onDump = ::std::option::Option<
    unsafe extern "C" fn(
        binder: *mut AIBinder,
        fd: ::std::os::raw::c_int,
        args: *mut *const ::std::os::raw::c_char,
        numArgs: u32,
    ) -> binder_status_t,
>;
extern "C" {
    #[doc = " This sets the implementation of the dump method for a class."]
    #[doc = ""]
    #[doc = " If this isn't set, nothing will be dumped when dump is called (for instance with"]
    #[doc = " android.os.Binder#dump). Must be called before any instance of the class is created."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param clazz class which should use this dump function"]
    #[doc = " \\param onDump function to call when an instance of this binder class is being dumped."]
    pub fn AIBinder_Class_setOnDump(clazz: *mut AIBinder_Class, onDump: AIBinder_onDump);
}
extern "C" {
    #[doc = " This tells users of this class not to use a transaction header. By default, libbinder_ndk users"]
    #[doc = " read/write transaction headers implicitly (in the SDK, this must be manually written by"]
    #[doc = " android.os.Parcel#writeInterfaceToken, and it is read/checked with"]
    #[doc = " android.os.Parcel#enforceInterface). This method is provided in order to talk to legacy code"]
    #[doc = " which does not write an interface token. When this is disabled, type safety is reduced, so you"]
    #[doc = " must have a separate way of determining the binder you are talking to is the right type. Must"]
    #[doc = " be called before any instance of the class is created."]
    #[doc = ""]
    #[doc = " Available since API level 33."]
    #[doc = ""]
    #[doc = " \\param clazz class to disable interface header on."]
    pub fn AIBinder_Class_disableInterfaceTokenHeader(clazz: *mut AIBinder_Class);
}
extern "C" {
    #[doc = " Creates a new binder object of the appropriate class."]
    #[doc = ""]
    #[doc = " Ownership of args is passed to this object. The lifecycle is implemented with AIBinder_incStrong"]
    #[doc = " and AIBinder_decStrong. When the reference count reaches zero, onDestroy is called."]
    #[doc = ""]
    #[doc = " When this is called, the refcount is implicitly 1. So, calling decStrong exactly one time is"]
    #[doc = " required to delete this object."]
    #[doc = ""]
    #[doc = " Once an AIBinder object is created using this API, re-creating that AIBinder for the same"]
    #[doc = " instance of the same class will break pointer equality for that specific AIBinder object. For"]
    #[doc = " instance, if someone erroneously created two AIBinder instances representing the same callback"]
    #[doc = " object and passed one to a hypothetical addCallback function and then later another one to a"]
    #[doc = " hypothetical removeCallback function, the remote process would have no way to determine that"]
    #[doc = " these two objects are actually equal using the AIBinder pointer alone (which they should be able"]
    #[doc = " to do). Also see the suggested memory ownership model suggested above."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param clazz the type of the object to be created."]
    #[doc = " \\param args the args to pass to AIBinder_onCreate for that class."]
    #[doc = ""]
    #[doc = " \\return a binder object representing the newly instantiated object."]
    pub fn AIBinder_new(
        clazz: *const AIBinder_Class,
        args: *mut ::std::os::raw::c_void,
    ) -> *mut AIBinder;
}
extern "C" {
    #[doc = " If this is hosted in a process other than the current one."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param binder the binder being queried."]
    #[doc = ""]
    #[doc = " \\return true if the AIBinder represents an object in another process."]
    pub fn AIBinder_isRemote(binder: *const AIBinder) -> bool;
}
extern "C" {
    #[doc = " If this binder is known to be alive. This will not send a transaction to a remote process and"]
    #[doc = " returns a result based on the last known information. That is, whenever a transaction is made,"]
    #[doc = " this is automatically updated to reflect the current alive status of this binder. This will be"]
    #[doc = " updated as the result of a transaction made using AIBinder_transact, but it will also be updated"]
    #[doc = " based on the results of bookkeeping or other transactions made internally."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param binder the binder being queried."]
    #[doc = ""]
    #[doc = " \\return true if the binder is alive."]
    pub fn AIBinder_isAlive(binder: *const AIBinder) -> bool;
}
extern "C" {
    #[doc = " Built-in transaction for all binder objects. This sends a transaction that will immediately"]
    #[doc = " return. Usually this is used to make sure that a binder is alive, as a placeholder call, or as a"]
    #[doc = " consistency check."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param binder the binder being queried."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK if the ping succeeds."]
    pub fn AIBinder_ping(binder: *mut AIBinder) -> binder_status_t;
}
extern "C" {
    #[doc = " Built-in transaction for all binder objects. This dumps information about a given binder."]
    #[doc = ""]
    #[doc = " See also AIBinder_Class_setOnDump, AIBinder_onDump."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param binder the binder to dump information about"]
    #[doc = " \\param fd where information should be dumped to"]
    #[doc = " \\param args null-terminated arguments to pass (may be null if numArgs is 0)"]
    #[doc = " \\param numArgs number of args to send"]
    #[doc = ""]
    #[doc = " \\return STATUS_OK if dump succeeds (or if there is nothing to dump)"]
    pub fn AIBinder_dump(
        binder: *mut AIBinder,
        fd: ::std::os::raw::c_int,
        args: *mut *const ::std::os::raw::c_char,
        numArgs: u32,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Registers for notifications that the associated binder is dead. The same death recipient may be"]
    #[doc = " associated with multiple different binders. If the binder is local, then no death recipient will"]
    #[doc = " be given (since if the local process dies, then no recipient will exist to receive a"]
    #[doc = " transaction). The cookie is passed to recipient in the case that this binder dies and can be"]
    #[doc = " null. The exact cookie must also be used to unlink this transaction (see AIBinder_unlinkToDeath)."]
    #[doc = " This function may return a binder transaction failure. The cookie can be used both for"]
    #[doc = " identification and holding user data."]
    #[doc = ""]
    #[doc = " If binder is local, this will return STATUS_INVALID_OPERATION."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param binder the binder object you want to receive death notifications from."]
    #[doc = " \\param recipient the callback that will receive notifications when/if the binder dies."]
    #[doc = " \\param cookie the value that will be passed to the death recipient on death."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on success."]
    pub fn AIBinder_linkToDeath(
        binder: *mut AIBinder,
        recipient: *mut AIBinder_DeathRecipient,
        cookie: *mut ::std::os::raw::c_void,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Stops registration for the associated binder dying. Does not delete the recipient. This function"]
    #[doc = " may return a binder transaction failure and in case the death recipient cannot be found, it"]
    #[doc = " returns STATUS_NAME_NOT_FOUND."]
    #[doc = ""]
    #[doc = " This only ever needs to be called when the AIBinder_DeathRecipient remains for use with other"]
    #[doc = " AIBinder objects. If the death recipient is deleted, all binders will automatically be unlinked."]
    #[doc = " If the binder dies, it will automatically unlink. If the binder is deleted, it will be"]
    #[doc = " automatically unlinked."]
    #[doc = ""]
    #[doc = " Be aware that it is not safe to immediately deallocate the cookie when this call returns. If you"]
    #[doc = " need to clean up the cookie, you should do so in the onUnlinked callback, which can be set using"]
    #[doc = " AIBinder_DeathRecipient_setOnUnlinked."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param binder the binder object to remove a previously linked death recipient from."]
    #[doc = " \\param recipient the callback to remove."]
    #[doc = " \\param cookie the cookie used to link to death."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on success. STATUS_NAME_NOT_FOUND if the binder cannot be found to be unlinked."]
    pub fn AIBinder_unlinkToDeath(
        binder: *mut AIBinder,
        recipient: *mut AIBinder_DeathRecipient,
        cookie: *mut ::std::os::raw::c_void,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " This returns the calling UID assuming that this thread is called from a thread that is processing"]
    #[doc = " a binder transaction (for instance, in the implementation of AIBinder_Class_onTransact)."]
    #[doc = ""]
    #[doc = " This can be used with higher-level system services to determine the caller's identity and check"]
    #[doc = " permissions."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\return calling uid or the current process's UID if this thread isn't processing a transaction."]
    pub fn AIBinder_getCallingUid() -> uid_t;
}
extern "C" {
    #[doc = " This returns the calling PID assuming that this thread is called from a thread that is processing"]
    #[doc = " a binder transaction (for instance, in the implementation of AIBinder_Class_onTransact)."]
    #[doc = ""]
    #[doc = " This can be used with higher-level system services to determine the caller's identity and check"]
    #[doc = " permissions. However, when doing this, one should be aware of possible TOCTOU problems when the"]
    #[doc = " calling process dies and is replaced with another process with elevated permissions and the same"]
    #[doc = " PID."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\return calling pid or the current process's PID if this thread isn't processing a transaction."]
    #[doc = " If the transaction being processed is a oneway transaction, then this method will return 0."]
    pub fn AIBinder_getCallingPid() -> pid_t;
}
extern "C" {
    #[doc = " Determine whether the current thread is currently executing an incoming transaction."]
    #[doc = ""]
    #[doc = " \\return true if the current thread is currently executing an incoming transaction, and false"]
    #[doc = " otherwise."]
    pub fn AIBinder_isHandlingTransaction() -> bool;
}
extern "C" {
    #[doc = " This can only be called if a strong reference to this object already exists in process."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param binder the binder object to add a refcount to."]
    pub fn AIBinder_incStrong(binder: *mut AIBinder);
}
extern "C" {
    #[doc = " This will delete the object and call onDestroy once the refcount reaches zero."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param binder the binder object to remove a refcount from."]
    pub fn AIBinder_decStrong(binder: *mut AIBinder);
}
extern "C" {
    #[doc = " For debugging only!"]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param binder the binder object to retrieve the refcount of."]
    #[doc = ""]
    #[doc = " \\return the number of strong-refs on this binder in this process. If binder is null, this will be"]
    #[doc = " -1."]
    pub fn AIBinder_debugGetRefCount(binder: *mut AIBinder) -> i32;
}
extern "C" {
    #[doc = " This sets the class of an AIBinder object. This checks to make sure the remote object is of"]
    #[doc = " the expected class. A class must be set in order to use transactions on an AIBinder object."]
    #[doc = " However, if an object is just intended to be passed through to another process or used as a"]
    #[doc = " handle this need not be called."]
    #[doc = ""]
    #[doc = " This returns true if the class association succeeds. If it fails, no change is made to the"]
    #[doc = " binder object."]
    #[doc = ""]
    #[doc = " Warning: this may fail if the binder is dead."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param binder the object to attach the class to."]
    #[doc = " \\param clazz the clazz to attach to binder."]
    #[doc = ""]
    #[doc = " \\return true if the binder has the class clazz and if the association was successful."]
    pub fn AIBinder_associateClass(binder: *mut AIBinder, clazz: *const AIBinder_Class) -> bool;
}
extern "C" {
    #[doc = " Returns the class that this binder was constructed with or associated with."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param binder the object that is being queried."]
    #[doc = ""]
    #[doc = " \\return the class that this binder is associated with. If this binder wasn't created with"]
    #[doc = " AIBinder_new, and AIBinder_associateClass hasn't been called, then this will return null."]
    pub fn AIBinder_getClass(binder: *mut AIBinder) -> *const AIBinder_Class;
}
extern "C" {
    #[doc = " Value returned by onCreate for a local binder. For stateless classes (if onCreate returns"]
    #[doc = " null), this also returns null. For a remote binder, this will always return null."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param binder the object that is being queried."]
    #[doc = ""]
    #[doc = " \\return the userdata returned from AIBinder_onCreate when this object was created. This may be"]
    #[doc = " null for stateless objects. For remote objects, this is always null."]
    pub fn AIBinder_getUserData(binder: *mut AIBinder) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Creates a parcel to start filling out for a transaction. This will add a header to the"]
    #[doc = " transaction that corresponds to android.os.Parcel#writeInterfaceToken. This may add debugging"]
    #[doc = " or other information to the transaction for platform use or to enable other features to work. The"]
    #[doc = " contents of this header is a platform implementation detail, and it is required to use"]
    #[doc = " libbinder_ndk. This parcel is to be sent via AIBinder_transact and it represents the input data"]
    #[doc = " to the transaction. It is recommended to check if the object is local and call directly into its"]
    #[doc = " user data before calling this as the parceling and unparceling cost can be avoided. This AIBinder"]
    #[doc = " must be either built with a class or associated with a class before using this API."]
    #[doc = ""]
    #[doc = " This does not affect the ownership of binder. When this function succeeds, the in parcel's"]
    #[doc = " ownership is passed to the caller. At this point, the parcel can be filled out and passed to"]
    #[doc = " AIBinder_transact. Alternatively, if there is an error while filling out the parcel, it can be"]
    #[doc = " deleted with AParcel_delete."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param binder the binder object to start a transaction on."]
    #[doc = " \\param in out parameter for input data to the transaction."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on success. This will return STATUS_INVALID_OPERATION if the binder has not yet"]
    #[doc = " been associated with a class (see AIBinder_new and AIBinder_associateClass)."]
    pub fn AIBinder_prepareTransaction(
        binder: *mut AIBinder,
        in_: *mut *mut AParcel,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Transact using a parcel created from AIBinder_prepareTransaction. This actually communicates with"]
    #[doc = " the object representing this binder object. This also passes out a parcel to be used for the"]
    #[doc = " return transaction. This takes ownership of the in parcel and automatically deletes it after it"]
    #[doc = " is sent to the remote process. The output parcel is the result of the transaction. If the"]
    #[doc = " transaction has FLAG_ONEWAY, the out parcel will be empty. Otherwise, this will block until the"]
    #[doc = " remote process has processed the transaction, and the out parcel will contain the output data"]
    #[doc = " from transaction."]
    #[doc = ""]
    #[doc = " This does not affect the ownership of binder. The out parcel's ownership is passed to the caller"]
    #[doc = " and must be released with AParcel_delete when finished reading."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param binder the binder object to transact on."]
    #[doc = " \\param code the implementation-specific code representing which transaction should be taken."]
    #[doc = " \\param in the implementation-specific input data to this transaction."]
    #[doc = " \\param out the implementation-specific output data to this transaction."]
    #[doc = " \\param flags possible flags to alter the way in which the transaction is conducted or 0."]
    #[doc = ""]
    #[doc = " \\return the result from the kernel or from the remote process. Usually, implementation-specific"]
    #[doc = " error codes are written to the output parcel, and the transaction code is reserved for kernel"]
    #[doc = " errors or error codes that have been repeated from subsequent transactions."]
    pub fn AIBinder_transact(
        binder: *mut AIBinder,
        code: transaction_code_t,
        in_: *mut *mut AParcel,
        out: *mut *mut AParcel,
        flags: binder_flags_t,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " This does not take any ownership of the input binder, but it can be used to retrieve it if"]
    #[doc = " something else in some process still holds a reference to it."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param binder object to create a weak pointer to."]
    #[doc = ""]
    #[doc = " \\return object representing a weak pointer to binder (or null if binder is null)."]
    pub fn AIBinder_Weak_new(binder: *mut AIBinder) -> *mut AIBinder_Weak;
}
extern "C" {
    #[doc = " Deletes the weak reference. This will have no impact on the lifetime of the binder."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param weakBinder object created with AIBinder_Weak_new."]
    pub fn AIBinder_Weak_delete(weakBinder: *mut AIBinder_Weak);
}
extern "C" {
    #[doc = " If promotion succeeds, result will have one strong refcount added to it. Otherwise, this returns"]
    #[doc = " null."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param weakBinder weak pointer to attempt retrieving the original object from."]
    #[doc = ""]
    #[doc = " \\return an AIBinder object with one refcount given to the caller or null."]
    pub fn AIBinder_Weak_promote(weakBinder: *mut AIBinder_Weak) -> *mut AIBinder;
}
#[doc = " This function is executed on death receipt. See AIBinder_linkToDeath/AIBinder_unlinkToDeath."]
#[doc = ""]
#[doc = " Available since API level 29."]
#[doc = ""]
#[doc = " \\param cookie the cookie passed to AIBinder_linkToDeath."]
pub type AIBinder_DeathRecipient_onBinderDied =
    ::std::option::Option<unsafe extern "C" fn(cookie: *mut ::std::os::raw::c_void)>;
#[doc = " This function is intended for cleaning up the data in the provided cookie, and it is executed"]
#[doc = " when the DeathRecipient is unlinked. When the DeathRecipient is unlinked due to a death receipt,"]
#[doc = " this method is called after the call to onBinderDied."]
#[doc = ""]
#[doc = " This method is called once for each binder that is unlinked. Hence, if the same cookie is passed"]
#[doc = " to multiple binders, then the caller is responsible for reference counting the cookie."]
#[doc = ""]
#[doc = " See also AIBinder_linkToDeath/AIBinder_unlinkToDeath."]
#[doc = ""]
#[doc = " Available since API level 33."]
#[doc = ""]
#[doc = " \\param cookie the cookie passed to AIBinder_linkToDeath."]
pub type AIBinder_DeathRecipient_onBinderUnlinked =
    ::std::option::Option<unsafe extern "C" fn(cookie: *mut ::std::os::raw::c_void)>;
extern "C" {
    #[doc = " Creates a new binder death recipient. This can be attached to multiple different binder objects."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param onBinderDied the callback to call when this death recipient is invoked."]
    #[doc = ""]
    #[doc = " \\return the newly constructed object (or null if onBinderDied is null)."]
    pub fn AIBinder_DeathRecipient_new(
        onBinderDied: AIBinder_DeathRecipient_onBinderDied,
    ) -> *mut AIBinder_DeathRecipient;
}
extern "C" {
    #[doc = " Set the callback to be called when this DeathRecipient is unlinked from a binder. The callback is"]
    #[doc = " called in the following situations:"]
    #[doc = ""]
    #[doc = "  1. If the binder died, shortly after the call to onBinderDied."]
    #[doc = "  2. If the binder is explicitly unlinked with AIBinder_unlinkToDeath or"]
    #[doc = "     AIBinder_DeathRecipient_delete."]
    #[doc = "  3. During or shortly after the AIBinder_linkToDeath call if it returns an error."]
    #[doc = ""]
    #[doc = " It is guaranteed that the callback is called exactly once for each call to linkToDeath unless the"]
    #[doc = " process is aborted before the binder is unlinked."]
    #[doc = ""]
    #[doc = " Be aware that when the binder is explicitly unlinked, it is not guaranteed that onUnlinked has"]
    #[doc = " been called before the call to AIBinder_unlinkToDeath or AIBinder_DeathRecipient_delete returns."]
    #[doc = " For example, if the binder dies concurrently with a call to AIBinder_unlinkToDeath, the binder is"]
    #[doc = " not unlinked until after the death notification is delivered, even if AIBinder_unlinkToDeath"]
    #[doc = " returns before that happens."]
    #[doc = ""]
    #[doc = " This method should be called before linking the DeathRecipient to a binder because the function"]
    #[doc = " pointer is cached. If you change it after linking to a binder, it is unspecified whether the old"]
    #[doc = " binder will call the old or new onUnlinked callback."]
    #[doc = ""]
    #[doc = " The onUnlinked argument may be null. In this case, no notification is given when the binder is"]
    #[doc = " unlinked."]
    #[doc = ""]
    #[doc = " Available since API level 33."]
    #[doc = ""]
    #[doc = " \\param recipient the DeathRecipient to set the onUnlinked callback for."]
    #[doc = " \\param onUnlinked the callback to call when a binder is unlinked from recipient."]
    pub fn AIBinder_DeathRecipient_setOnUnlinked(
        recipient: *mut AIBinder_DeathRecipient,
        onUnlinked: AIBinder_DeathRecipient_onBinderUnlinked,
    );
}
extern "C" {
    #[doc = " Deletes a binder death recipient. It is not necessary to call AIBinder_unlinkToDeath before"]
    #[doc = " calling this as these will all be automatically unlinked."]
    #[doc = ""]
    #[doc = " Be aware that it is not safe to immediately deallocate the cookie when this call returns. If you"]
    #[doc = " need to clean up the cookie, you should do so in the onUnlinked callback, which can be set using"]
    #[doc = " AIBinder_DeathRecipient_setOnUnlinked."]
    #[doc = ""]
    #[doc = " Available since API level 29."]
    #[doc = ""]
    #[doc = " \\param recipient the binder to delete (previously created with AIBinder_DeathRecipient_new)."]
    pub fn AIBinder_DeathRecipient_delete(recipient: *mut AIBinder_DeathRecipient);
}
extern "C" {
    #[doc = " Gets the extension registered with AIBinder_setExtension."]
    #[doc = ""]
    #[doc = " See AIBinder_setExtension."]
    #[doc = ""]
    #[doc = " Available since API level 30."]
    #[doc = ""]
    #[doc = " \\param binder the object to get the extension of."]
    #[doc = " \\param outExt the returned extension object. Will be null if there is no extension set or"]
    #[doc = " non-null with one strong ref count."]
    #[doc = ""]
    #[doc = " \\return error of getting the interface (may be a transaction error if this is"]
    #[doc = " remote binder). STATUS_UNEXPECTED_NULL if binder is null."]
    pub fn AIBinder_getExtension(
        binder: *mut AIBinder,
        outExt: *mut *mut AIBinder,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Gets the extension of a binder interface. This allows a downstream developer to add"]
    #[doc = " an extension to an interface without modifying its interface file. This should be"]
    #[doc = " called immediately when the object is created before it is passed to another thread."]
    #[doc = " No thread safety is required."]
    #[doc = ""]
    #[doc = " For instance, imagine if we have this interface:"]
    #[doc = "     interface IFoo { void doFoo(); }"]
    #[doc = ""]
    #[doc = " A). Historical option that has proven to be BAD! Only the original"]
    #[doc = "     author of an interface should change an interface. If someone"]
    #[doc = "     downstream wants additional functionality, they should not ever"]
    #[doc = "     change the interface or use this method."]
    #[doc = ""]
    #[doc = "    BAD TO DO:  interface IFoo {                       BAD TO DO"]
    #[doc = "    BAD TO DO:      void doFoo();                      BAD TO DO"]
    #[doc = "    BAD TO DO: +    void doBar(); // adding a method   BAD TO DO"]
    #[doc = "    BAD TO DO:  }                                      BAD TO DO"]
    #[doc = ""]
    #[doc = " B). Option that this method enables."]
    #[doc = "     Leave the original interface unchanged (do not change IFoo!)."]
    #[doc = "     Instead, create a new interface in a downstream package:"]
    #[doc = ""]
    #[doc = "         package com.<name>; // new functionality in a new package"]
    #[doc = "         interface IBar { void doBar(); }"]
    #[doc = ""]
    #[doc = "     When registering the interface, add:"]
    #[doc = "         std::shared_ptr<MyFoo> foo = new MyFoo; // class in AOSP codebase"]
    #[doc = "         std::shared_ptr<MyBar> bar = new MyBar; // custom extension class"]
    #[doc = "         ... = AIBinder_setExtension(foo->asBinder().get(), bar->asBinder().get());"]
    #[doc = "         // handle error"]
    #[doc = ""]
    #[doc = "     Then, clients of IFoo can get this extension:"]
    #[doc = "         SpAIBinder binder = ...;"]
    #[doc = "         std::shared_ptr<IFoo> foo = IFoo::fromBinder(binder); // handle if null"]
    #[doc = "         SpAIBinder barBinder;"]
    #[doc = "         ... = AIBinder_getExtension(barBinder.get());"]
    #[doc = "         // handle error"]
    #[doc = "         std::shared_ptr<IBar> bar = IBar::fromBinder(barBinder);"]
    #[doc = "         // type is checked with AIBinder_associateClass"]
    #[doc = "         // if bar is null, then there is no extension or a different"]
    #[doc = "         // type of extension"]
    #[doc = ""]
    #[doc = " Available since API level 30."]
    #[doc = ""]
    #[doc = " \\param binder the object to get the extension on. Must be local."]
    #[doc = " \\param ext the extension to set (binder will hold a strong reference to this)"]
    #[doc = ""]
    #[doc = " \\return OK on success, STATUS_INVALID_OPERATION if binder is not local, STATUS_UNEXPECTED_NULL"]
    #[doc = " if either binder is null."]
    pub fn AIBinder_setExtension(binder: *mut AIBinder, ext: *mut AIBinder) -> binder_status_t;
}
extern "C" {
    #[doc = " Retrieve the class descriptor for the class."]
    #[doc = ""]
    #[doc = " Available since API level 31."]
    #[doc = ""]
    #[doc = " \\param clazz the class to fetch the descriptor from"]
    #[doc = ""]
    #[doc = " \\return the class descriptor string. This pointer will never be null; a"]
    #[doc = " descriptor is required to define a class. The pointer is owned by the class"]
    #[doc = " and will remain valid as long as the class does. For a local class, this will"]
    #[doc = " be the same value (not necessarily pointer equal) as is passed into"]
    #[doc = " AIBinder_Class_define. Format is utf-8."]
    pub fn AIBinder_Class_getDescriptor(
        clazz: *const AIBinder_Class,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Whether AIBinder is less than another."]
    #[doc = ""]
    #[doc = " This provides a per-process-unique total ordering of binders where a null"]
    #[doc = " AIBinder* object is considered to be before all other binder objects."]
    #[doc = " For instance, two binders refer to the same object in a local or remote"]
    #[doc = " process when both AIBinder_lt(a, b) and AIBinder(b, a) are false. This API"]
    #[doc = " might be used to insert and lookup binders in binary search trees."]
    #[doc = ""]
    #[doc = " AIBinder* pointers themselves actually also create a per-process-unique total"]
    #[doc = " ordering. However, this ordering is inconsistent with AIBinder_Weak_lt for"]
    #[doc = " remote binders. So, in general, this function should be preferred."]
    #[doc = ""]
    #[doc = " Available since API level 31."]
    #[doc = ""]
    #[doc = " \\param lhs comparison object"]
    #[doc = " \\param rhs comparison object"]
    #[doc = ""]
    #[doc = " \\return whether \"lhs < rhs\" is true"]
    pub fn AIBinder_lt(lhs: *const AIBinder, rhs: *const AIBinder) -> bool;
}
extern "C" {
    #[doc = " Clone an AIBinder_Weak. Useful because even if a weak binder promotes to a"]
    #[doc = " null value, after further binder transactions, it may no longer promote to a"]
    #[doc = " null value."]
    #[doc = ""]
    #[doc = " Available since API level 31."]
    #[doc = ""]
    #[doc = " \\param weak Object to clone"]
    #[doc = ""]
    #[doc = " \\return clone of the input parameter. This must be deleted with"]
    #[doc = " AIBinder_Weak_delete. Null if weak input parameter is also null."]
    pub fn AIBinder_Weak_clone(weak: *const AIBinder_Weak) -> *mut AIBinder_Weak;
}
extern "C" {
    #[doc = " Whether AIBinder_Weak is less than another."]
    #[doc = ""]
    #[doc = " This provides a per-process-unique total ordering of binders which is exactly"]
    #[doc = " the same as AIBinder_lt. Similarly, a null AIBinder_Weak* is considered to be"]
    #[doc = " ordered before all other weak references."]
    #[doc = ""]
    #[doc = " This function correctly distinguishes binders even if one is deallocated. So,"]
    #[doc = " for instance, an AIBinder_Weak* entry representing a deleted binder will"]
    #[doc = " never compare as equal to an AIBinder_Weak* entry which represents a"]
    #[doc = " different allocation of a binder, even if the two binders were originally"]
    #[doc = " allocated at the same address. That is:"]
    #[doc = ""]
    #[doc = "     AIBinder* a = ...; // imagine this has address 0x8"]
    #[doc = "     AIBinder_Weak* bWeak = AIBinder_Weak_new(a);"]
    #[doc = "     AIBinder_decStrong(a); // a may be deleted, if this is the last reference"]
    #[doc = "     AIBinder* b = ...; // imagine this has address 0x8 (same address as b)"]
    #[doc = "     AIBinder_Weak* bWeak = AIBinder_Weak_new(b);"]
    #[doc = ""]
    #[doc = " Then when a/b are compared with other binders, their order will be preserved,"]
    #[doc = " and it will either be the case that AIBinder_Weak_lt(aWeak, bWeak) OR"]
    #[doc = " AIBinder_Weak_lt(bWeak, aWeak), but not both."]
    #[doc = ""]
    #[doc = " Unlike AIBinder*, the AIBinder_Weak* addresses themselves have nothing to do"]
    #[doc = " with the underlying binder."]
    #[doc = ""]
    #[doc = " Available since API level 31."]
    #[doc = ""]
    #[doc = " \\param lhs comparison object"]
    #[doc = " \\param rhs comparison object"]
    #[doc = ""]
    #[doc = " \\return whether \"lhs < rhs\" is true"]
    pub fn AIBinder_Weak_lt(lhs: *const AIBinder_Weak, rhs: *const AIBinder_Weak) -> bool;
}
extern "C" {
    #[doc = " Makes calls to AIBinder_getCallingSid work if the kernel supports it. This"]
    #[doc = " must be called on a local binder server before it is sent out to any othe"]
    #[doc = " process. If this is a remote binder, it will abort. If the kernel doesn't"]
    #[doc = " support this feature, you'll always get null from AIBinder_getCallingSid."]
    #[doc = ""]
    #[doc = " \\param binder local server binder to request security contexts on"]
    pub fn AIBinder_setRequestingSid(binder: *mut AIBinder, requestingSid: bool);
}
extern "C" {
    #[doc = " Returns the selinux context of the callee."]
    #[doc = ""]
    #[doc = " In order for this to work, the following conditions must be met:"]
    #[doc = " - The kernel must be new enough to support this feature."]
    #[doc = " - The server must have called AIBinder_setRequestingSid."]
    #[doc = " - The callee must be a remote process."]
    #[doc = ""]
    #[doc = " \\return security context or null if unavailable. The lifetime of this context"]
    #[doc = " is the lifetime of the transaction."]
    pub fn AIBinder_getCallingSid() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Sets a minimum scheduler policy for all transactions coming into this"]
    #[doc = " AIBinder."]
    #[doc = ""]
    #[doc = " This must be called before the object is sent to another process."]
    #[doc = " Aborts on invalid values. Not thread safe."]
    #[doc = ""]
    #[doc = " \\param binder local server binder to set the policy for"]
    #[doc = " \\param policy scheduler policy as defined in linux UAPI"]
    #[doc = " \\param priority priority. [-20..19] for SCHED_NORMAL, [1..99] for RT"]
    pub fn AIBinder_setMinSchedulerPolicy(
        binder: *mut AIBinder,
        policy: ::std::os::raw::c_int,
        priority: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Allow the binder to inherit realtime scheduling policies from its caller."]
    #[doc = ""]
    #[doc = " This must be called before the object is sent to another process. Not thread"]
    #[doc = " safe."]
    #[doc = ""]
    #[doc = " \\param binder local server binder to set the policy for"]
    #[doc = " \\param inheritRt whether to inherit realtime scheduling policies (default is"]
    #[doc = "     false)."]
    pub fn AIBinder_setInheritRt(binder: *mut AIBinder, inheritRt: bool);
}
extern "C" {
    #[doc = " This registers the service with the default service manager under this instance name. This does"]
    #[doc = " not take ownership of binder."]
    #[doc = ""]
    #[doc = " WARNING: when using this API across an APEX boundary, do not use with unstable"]
    #[doc = " AIDL services. TODO(b/139325195)"]
    #[doc = ""]
    #[doc = " \\param binder object to register globally with the service manager."]
    #[doc = " \\param instance identifier of the service. This will be used to lookup the service."]
    #[doc = ""]
    #[doc = " \\return EX_NONE on success."]
    pub fn AServiceManager_addService(
        binder: *mut AIBinder,
        instance: *const ::std::os::raw::c_char,
    ) -> binder_exception_t;
}
extern "C" {
    #[doc = " Gets a binder object with this specific instance name. Will return nullptr immediately if the"]
    #[doc = " service is not available This also implicitly calls AIBinder_incStrong (so the caller of this"]
    #[doc = " function is responsible for calling AIBinder_decStrong)."]
    #[doc = ""]
    #[doc = " WARNING: when using this API across an APEX boundary, do not use with unstable"]
    #[doc = " AIDL services. TODO(b/139325195)"]
    #[doc = ""]
    #[doc = " \\param instance identifier of the service used to lookup the service."]
    pub fn AServiceManager_checkService(instance: *const ::std::os::raw::c_char) -> *mut AIBinder;
}
extern "C" {
    #[doc = " Gets a binder object with this specific instance name. Blocks for a couple of seconds waiting on"]
    #[doc = " it. This also implicitly calls AIBinder_incStrong (so the caller of this function is responsible"]
    #[doc = " for calling AIBinder_decStrong). This does polling. A more efficient way to make sure you"]
    #[doc = " unblock as soon as the service is available is to use AIBinder_waitForService."]
    #[doc = ""]
    #[doc = " WARNING: when using this API across an APEX boundary, do not use with unstable"]
    #[doc = " AIDL services. TODO(b/139325195)"]
    #[doc = ""]
    #[doc = " WARNING: when using this API, typically, you should call it in a loop. It's dangerous to"]
    #[doc = " assume that nullptr could mean that the service is not available. The service could just"]
    #[doc = " be starting. Generally, whether a service exists, this information should be declared"]
    #[doc = " externally (for instance, an Android feature might imply the existence of a service,"]
    #[doc = " a system property, or in the case of services in the VINTF manifest, it can be checked"]
    #[doc = " with AServiceManager_isDeclared)."]
    #[doc = ""]
    #[doc = " \\param instance identifier of the service used to lookup the service."]
    pub fn AServiceManager_getService(instance: *const ::std::os::raw::c_char) -> *mut AIBinder;
}
extern "C" {
    #[doc = " Registers a lazy service with the default service manager under the 'instance' name."]
    #[doc = " Does not take ownership of binder."]
    #[doc = " The service must be configured statically with init so it can be restarted with"]
    #[doc = " ctl.interface.* messages from servicemanager."]
    #[doc = " AServiceManager_registerLazyService cannot safely be used with AServiceManager_addService"]
    #[doc = " in the same process. If one service is registered with AServiceManager_registerLazyService,"]
    #[doc = " the entire process will have its lifetime controlled by servicemanager."]
    #[doc = " Instead, all services in the process should be registered using"]
    #[doc = " AServiceManager_registerLazyService."]
    #[doc = ""]
    #[doc = " \\param binder object to register globally with the service manager."]
    #[doc = " \\param instance identifier of the service. This will be used to lookup the service."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on success."]
    pub fn AServiceManager_registerLazyService(
        binder: *mut AIBinder,
        instance: *const ::std::os::raw::c_char,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Gets a binder object with this specific instance name. Efficiently waits for the service."]
    #[doc = " If the service is not declared, it will wait indefinitely. Requires the threadpool"]
    #[doc = " to be started in the service."]
    #[doc = " This also implicitly calls AIBinder_incStrong (so the caller of this function is responsible"]
    #[doc = " for calling AIBinder_decStrong)."]
    #[doc = ""]
    #[doc = " WARNING: when using this API across an APEX boundary, do not use with unstable"]
    #[doc = " AIDL services. TODO(b/139325195)"]
    #[doc = ""]
    #[doc = " \\param instance identifier of the service used to lookup the service."]
    #[doc = ""]
    #[doc = " \\return service if registered, null if not."]
    pub fn AServiceManager_waitForService(instance: *const ::std::os::raw::c_char)
        -> *mut AIBinder;
}
extern "C" {
    #[doc = " Check if a service is declared (e.g. VINTF manifest)."]
    #[doc = ""]
    #[doc = " \\param instance identifier of the service."]
    #[doc = ""]
    #[doc = " \\return true on success, meaning AServiceManager_waitForService should always"]
    #[doc = "    be able to return the service."]
    pub fn AServiceManager_isDeclared(instance: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[doc = " Returns all declared instances for a particular interface."]
    #[doc = ""]
    #[doc = " For instance, if 'android.foo.IFoo/foo' is declared, and 'android.foo.IFoo' is"]
    #[doc = " passed here, then [\"foo\"] would be returned."]
    #[doc = ""]
    #[doc = " See also AServiceManager_isDeclared."]
    #[doc = ""]
    #[doc = " \\param interface interface, e.g. 'android.foo.IFoo'"]
    #[doc = " \\param context to pass to callback"]
    #[doc = " \\param callback taking instance (e.g. 'foo') and context"]
    pub fn AServiceManager_forEachDeclaredInstance(
        interface: *const ::std::os::raw::c_char,
        context: *mut ::std::os::raw::c_void,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_char,
                arg2: *mut ::std::os::raw::c_void,
            ),
        >,
    );
}
extern "C" {
    #[doc = " Check if a service is updatable via an APEX module."]
    #[doc = ""]
    #[doc = " \\param instance identifier of the service"]
    #[doc = ""]
    #[doc = " \\return whether the interface is updatable via APEX"]
    pub fn AServiceManager_isUpdatableViaApex(instance: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[doc = " Prevent lazy services without client from shutting down their process"]
    #[doc = ""]
    #[doc = " This should only be used if it is every eventually set to false. If a"]
    #[doc = " service needs to persist but doesn't need to dynamically shut down,"]
    #[doc = " prefer to control it with another mechanism."]
    #[doc = ""]
    #[doc = " \\param persist 'true' if the process should not exit."]
    pub fn AServiceManager_forceLazyServicesPersist(persist: bool);
}
extern "C" {
    #[doc = " Set a callback that is invoked when the active service count (i.e. services with clients)"]
    #[doc = " registered with this process drops to zero (or becomes nonzero)."]
    #[doc = " The callback takes a boolean argument, which is 'true' if there is"]
    #[doc = " at least one service with clients."]
    #[doc = ""]
    #[doc = " \\param callback function to call when the number of services"]
    #[doc = "    with clients changes."]
    #[doc = " \\param context opaque pointer passed back as second parameter to the"]
    #[doc = " callback."]
    #[doc = ""]
    #[doc = " The callback takes two arguments. The first is a boolean that represents if there are"]
    #[doc = " services with clients (true) or not (false)."]
    #[doc = " The second is the 'context' pointer passed during the registration."]
    #[doc = ""]
    #[doc = " Callback return value:"]
    #[doc = " - false: Default behavior for lazy services (shut down the process if there"]
    #[doc = "          are no clients)."]
    #[doc = " - true:  Don't shut down the process even if there are no clients."]
    #[doc = ""]
    #[doc = " This callback gives a chance to:"]
    #[doc = " 1 - Perform some additional operations before exiting;"]
    #[doc = " 2 - Prevent the process from exiting by returning \"true\" from the callback."]
    pub fn AServiceManager_setActiveServicesCallback(
        callback: ::std::option::Option<
            unsafe extern "C" fn(arg1: bool, arg2: *mut ::std::os::raw::c_void) -> bool,
        >,
        context: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Try to unregister all services previously registered with 'registerService'."]
    #[doc = ""]
    #[doc = " \\return true on success."]
    pub fn AServiceManager_tryUnregister() -> bool;
}
extern "C" {
    #[doc = " Re-register services that were unregistered by 'tryUnregister'."]
    #[doc = " This method should be called in the case 'tryUnregister' fails"]
    #[doc = " (and should be called on the same thread)."]
    pub fn AServiceManager_reRegister();
}
extern "C" {
    #[doc = " Gets whether or not FDs are allowed by this AParcel"]
    #[doc = ""]
    #[doc = " \\return true if FDs are allowed, false if they are not. That is"]
    #[doc = " if this returns false then AParcel_writeParcelFileDescriptor will"]
    #[doc = " return STATUS_FDS_NOT_ALLOWED."]
    pub fn AParcel_getAllowFds(arg1: *const AParcel) -> bool;
}
extern "C" {
    #[doc = " Data written to the parcel will be zero'd before being deleted or realloced."]
    #[doc = ""]
    #[doc = " The main use of this is marking a parcel that will be used in a transaction"]
    #[doc = " with FLAG_CLEAR_BUF. When FLAG_CLEAR_BUF is used, the reply parcel will"]
    #[doc = " automatically be marked as sensitive when it is created."]
    #[doc = ""]
    #[doc = " \\param parcel The parcel to clear associated data from."]
    pub fn AParcel_markSensitive(parcel: *const AParcel);
}
extern "C" {
    #[doc = " This creates a threadpool for incoming binder transactions if it has not already been created."]
    #[doc = ""]
    #[doc = " When using this, it is expected that ABinderProcess_setupPolling and"]
    #[doc = " ABinderProcess_handlePolledCommands are not used."]
    pub fn ABinderProcess_startThreadPool();
}
extern "C" {
    #[doc = " This sets the maximum number of threads that can be started in the threadpool. By default, after"]
    #[doc = " startThreadPool is called, this is 15. If it is called additional times, it will only prevent"]
    #[doc = " the kernel from starting new threads and will not delete already existing threads."]
    pub fn ABinderProcess_setThreadPoolMaxThreadCount(numThreads: u32) -> bool;
}
extern "C" {
    #[doc = " This adds the current thread to the threadpool. This may cause the threadpool to exceed the"]
    #[doc = " maximum size."]
    pub fn ABinderProcess_joinThreadPool();
}
extern "C" {
    #[doc = " This gives you an fd to wait on. Whenever data is available on the fd,"]
    #[doc = " ABinderProcess_handlePolledCommands can be called to handle binder queries."]
    #[doc = " This is expected to be used in a single threaded process which waits on"]
    #[doc = " events from multiple different fds."]
    #[doc = ""]
    #[doc = " When using this, it is expected ABinderProcess_startThreadPool and"]
    #[doc = " ABinderProcess_joinThreadPool are not used."]
    #[doc = ""]
    #[doc = " \\param fd out param corresponding to the binder domain opened in this"]
    #[doc = " process."]
    #[doc = " \\return STATUS_OK on success"]
    pub fn ABinderProcess_setupPolling(fd: *mut ::std::os::raw::c_int) -> binder_status_t;
}
extern "C" {
    #[doc = " This will handle all queued binder commands in this process and then return."]
    #[doc = " It is expected to be called whenever there is data on the fd."]
    #[doc = ""]
    #[doc = " \\return STATUS_OK on success"]
    pub fn ABinderProcess_handlePolledCommands() -> binder_status_t;
}
#[doc = " Function to execute a shell command."]
#[doc = ""]
#[doc = " Available since API level 30."]
#[doc = ""]
#[doc = " \\param binder the binder executing the command"]
#[doc = " \\param in input file descriptor, should be flushed, ownership is not passed"]
#[doc = " \\param out output file descriptor, should be flushed, ownership is not passed"]
#[doc = " \\param err error file descriptor, should be flushed, ownership is not passed"]
#[doc = " \\param argv array of null-terminated strings for command (may be null if argc"]
#[doc = " is 0)"]
#[doc = " \\param argc length of argv array"]
#[doc = ""]
#[doc = " \\return binder_status_t result of transaction"]
pub type AIBinder_handleShellCommand = ::std::option::Option<
    unsafe extern "C" fn(
        binder: *mut AIBinder,
        in_: ::std::os::raw::c_int,
        out: ::std::os::raw::c_int,
        err: ::std::os::raw::c_int,
        argv: *mut *const ::std::os::raw::c_char,
        argc: u32,
    ) -> binder_status_t,
>;
extern "C" {
    #[doc = " This sets the implementation of handleShellCommand for a class."]
    #[doc = ""]
    #[doc = " If this isn't set, nothing will be executed when handleShellCommand is called."]
    #[doc = ""]
    #[doc = " Available since API level 30."]
    #[doc = ""]
    #[doc = " \\param handleShellCommand function to call when a shell transaction is"]
    #[doc = " received"]
    pub fn AIBinder_Class_setHandleShellCommand(
        clazz: *mut AIBinder_Class,
        handleShellCommand: AIBinder_handleShellCommand,
    );
}
extern "C" {
    #[doc = " This interface has the stability of the system image."]
    pub fn AIBinder_markSystemStability(binder: *mut AIBinder);
}
extern "C" {
    #[doc = " Given a binder interface at a certain stability, there may be some"]
    #[doc = " requirements associated with that higher stability level. For instance, a"]
    #[doc = " VINTF stability binder is required to be in the VINTF manifest. This API"]
    #[doc = " can be called to use that same interface within the system partition."]
    pub fn AIBinder_forceDowngradeToSystemStability(binder: *mut AIBinder);
}
extern "C" {
    pub fn AIBinder_markVintfStability(binder: *mut AIBinder);
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum android_c_interface_StatusCode {
    OK = 0,
    UNKNOWN_ERROR = -2147483648,
    NO_MEMORY = -12,
    INVALID_OPERATION = -38,
    BAD_VALUE = -22,
    BAD_TYPE = -2147483647,
    NAME_NOT_FOUND = -2,
    PERMISSION_DENIED = -1,
    NO_INIT = -19,
    ALREADY_EXISTS = -17,
    DEAD_OBJECT = -32,
    FAILED_TRANSACTION = -2147483646,
    BAD_INDEX = -75,
    NOT_ENOUGH_DATA = -61,
    WOULD_BLOCK = -11,
    TIMED_OUT = -110,
    UNKNOWN_TRANSACTION = -74,
    FDS_NOT_ALLOWED = -2147483641,
    UNEXPECTED_NULL = -2147483640,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum android_c_interface_ExceptionCode {
    NONE = 0,
    SECURITY = -1,
    BAD_PARCELABLE = -2,
    ILLEGAL_ARGUMENT = -3,
    NULL_POINTER = -4,
    ILLEGAL_STATE = -5,
    NETWORK_MAIN_THREAD = -6,
    UNSUPPORTED_OPERATION = -7,
    SERVICE_SPECIFIC = -8,
    PARCELABLE = -9,
    #[doc = " This is special, and indicates to native binder proxies that the"]
    #[doc = " transaction has failed at a low level."]
    TRANSACTION_FAILED = -129,
}
pub const FIRST_CALL_TRANSACTION: ::std::os::raw::c_uint = 1;
pub const LAST_CALL_TRANSACTION: ::std::os::raw::c_uint = 16777215;
pub type android_c_interface_consts__bindgen_ty_1 = ::std::os::raw::c_uint;
pub const FLAG_ONEWAY: ::std::os::raw::c_uint = 1;
pub const FLAG_CLEAR_BUF: ::std::os::raw::c_uint = 32;
pub const FLAG_PRIVATE_LOCAL: ::std::os::raw::c_uint = 0;
pub type android_c_interface_consts__bindgen_ty_2 = ::std::os::raw::c_uint;
